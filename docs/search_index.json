[["index.html", "Fall 2020 EDAV Community Contributions Chapter 1 Instructions 1.1 Background 1.2 Preparing your .Rmd file 1.3 Submission steps 1.4 Optional tweaks 1.5 FAQ", " Fall 2020 EDAV Community Contributions 2020-11-18 Chapter 1 Instructions This chapter gives you all the information you need to upload your community contribution. Please read this entire document carefully before making your submission. Of particular note is the fact that bookdown requires a different .Rmd format than you’re used to, so you must make changes to the beginning of the file as described below before submitting. 1.1 Background This web site makes use of the bookdown package to render a collection of .Rmd files into a nicely formatted online book with chapters and subchapters. Your job will be to submit a slightly modified version of your community contribution .Rmd file to the GitHub repository where the source files for this web site are stored. On the backend, the admins will divide the chapters into book sections and order them. If your community contribution is in a different format, then create a short .Rmd file that explains what you did, and includes links to any relevant files, such as slides, etc. which you can post on your GitHub repo (or another online site.) 1.2 Preparing your .Rmd file You should only submit ONE Rmd file. After completing these modifications, your .Rmd should look like this sample .Rmd. Create a concise, descriptive name for your project. For instance, name it base_r_ggplot_graph or something similar if your work is about contrasting/working with base R graphics and ggplot2 graphics. Check the .Rmd filenames in the project repo to make sure your name isn’t already taken. Your project name should be words only and joined with underscores, no white space. In addition, all letters must be lowercase. Create a copy of your .Rmd file with the new name. Completely delete the YAML header (the section at the top of the .Rmd that includes name, title, date, output, etc.) including the --- line. Choose a short, descriptive, human readable title for your project as your title will show up in the table of contents – look at examples in the 2019 EDAV rendered book of community contributions https://jtr13.github.io/cc19. Capitalize the first letter only (“sentence case”). On the first line of your document, enter a single hashtag, followed by a single whitespace, and then your title. It is important to follow this format so that bookdown renders your title as a header. Do not use single # headers anywhere else in the document. Note: if your chapter is the first in a section, a second # header and section description will be requested during the pull-request and merge phase. The second line should be blank, followed by your name(s): # Base R vs. ggplot2 Aaron Burr and Alexander Hamilton Your content starts here. If your project requires data, please use a built-in dataset or read directly from a URL, such as: df &lt;- readr::read_csv(\"https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv\") If you absolutely must include a data file, please use a small one, as for many reasons it is desirable to keep the repository size as small as possible. If you have included a setup chunk in your Rmd file, please remember to remove the label setup in the chunk, i.e., use: {r, include=FALSE} instead of: {r setup, include=FALSE} If your project requires libraries to be installed and included in the document, please adhere to the following conventions. Do not evaluate any install.packages() statements in your document. Consumers of an Rmd file won’t want packages to get installed when they knit your document. Include any library() statements at the top of your Rmd file, below the title, name, and setup, but above any content. If your chapter requires the installation of a package from source (is a GitHub installation), please add a comment identifying it as such. Here is an example library() section with install statements that won’t be evaluated: install.packages(&quot;devtools&quot;) # used for installation from source install.packages(&quot;dplyr&quot;) install.packages(&quot;ggplot2&quot;) library(&quot;devtools&quot;) devtools::install_github(&quot;twitter/AnomalyDetection&quot;) library(&quot;AnomalyDetection&quot;) # must be installed from source library(&quot;dplyr&quot;) library(&quot;ggplot2&quot;) You could include both sections, or you could just include the second library() section and trust R users to install any packages themselves. If you developed your Rmd file before moving your library() statements above the rest of the file content, it is highly recommended to knit and review your document again. This may change the namespace that was available in each section of your code during development, causing a function not to work or to exhibit unexpected behavior. This common issue is mentioned in the EDAV R Basics “Functions stop working” section. Want to get fancy? See the optional tweaks section below. 1.3 Submission steps To submit your work, we will be following “Workflow #4” – that is submitting a pull request to someone else’s repository to which you do not have write access. Instructions are available in this tutorial. They are repeated below in abbreviated form, with specific instructions on naming conventions, content information, and other important details. Fork cc20 repo (this repo) to your GitHub account. Clone/download the forked repo to your local computer. Create a new branch and name it with your project name, in our case sample_project. Do not skip this step. We will not merge your PR if it doesn’t come from a branch. If you already forgot to do this, check this tutorial for how to fix it. Copy your modified .Rmd file with the same name into the root directory on the branch. In our example, it is sample_project.Rmd. Do not include an .html file. (In order for the bookdown package to work, all .Rmd files will be rendered behind the scenes.) [OPTIONAL] If you have other resources (such as images) included in your project, create a folder under resources/. In our example, it is resources/sample_project/. Put the resources files there. Be sure to change all the links in your .Rmd to include resources/.../, for example: ![Test Photo](resources/sample_project/election.jpg) When you are ready to submit your project, push your branch to your remote repo. Follow this tutorial to create a pull request. At this point a back and forth will begin with the team managing the pull requests. If you are asked to make changes, simply make the changes on your local branch, save, commit, and push to GitHub. The new commits will be added to your pull request; you do not need to, and should not, create a new pull request. (If, based on the circumstances, it does make sense to close the pull request and start a new one, we will tell you.) Once your pull request is merged, it’s fine to delete your local clone (folder) as well as the forked repository in your GitHub account. 1.4 Optional tweaks If you prefer for links from your chapter to open in new tabs, add {target=\"_blank\"} after the link, such as: [edav.info](edav.info){target=\"_blank\"} Note that your headers (##, ###, etc.) will be converted to numbered headings as such: ## –&gt; 3.1 ### –&gt; 3.1.1 These headings will appear as chapter subheadings and sub-subheadings in the navigation panel on the left. Think about a logical structure for users to navigate your chapter. We recommend using only ## and ### headings since “sub-sub-subheadings” such as 4.1.3.4 are generally unnecessary and look messy. Unfortunately, there’s no simple way to preview your chapter before it’s actually merged into the project. (bookdown has preview_chapter() option but it only works after the entire book has been rendered at least once and that will become more and more complex and require more and more packages as the project grows.) If you really want to preview it, fork and clone this minimal bookdown repo, add your .Rmd file, click the “Build book” button on the Build tab (next to Git), and then open any of the .html files in the _book folder in a web browser to see the rendered book. (Do not click the Knit button as it will not build a bookdown book.) If you’re interested in more bookdown options, see the official reference book. Have more useful tweaks to share? Submit an issue or PR. 1.5 FAQ 1.5.1 What should I expect after creating a pull request? Within a week after you create a pull request, we will apply a label to it and assign an administrator who will review all the files you submit to see if they meet the requirements. It will take some time before we can process all the pull requests, so as long as you see your pull request has been labeled and assigned to an admin, don’t worry. However, if the admin contacts you regarding the pull request, that usually means your files fail to meet some requirements. The admin will clearly state what is wrong, so please fix them as soon as possible. 1.5.2 What if I catch mistakes after my pull request is merged? You may submit additional pull requests to fix material on the site. If the edits are small, such as fixing typos, it is easiest to make the edits directly on GitHub, following these instructions. We will merge first pull requests before edits, so please be patient. 1.5.3 Other questions If you encounter other problems, please submit an issue and we will look into it. Thank you for your contributions! "],["sample-project.html", "Chapter 2 Sample project", " Chapter 2 Sample project Joe Biden and Donald Trump This chapter gives a sample layout of your Rmd file. Test Photo "],["data-transformation-in-r.html", "Chapter 3 Data transformation in R 3.1 Introduction 3.2 Basics 3.3 Function Usage 3.4 Quick EDA: median arrival delays 3.5 External Resource", " Chapter 3 Data transformation in R Jiongxin Ye and Zhuoyan Ma 3.1 Introduction Data visualizations are nice and insightful, but we usually spend more time formatting, cleaning and wrangling the data. Sometimes, we need to transform the data to perform a better visualization, or maybe we just want to rename the variables and get summaries. No matter for detect factual information or implicit relationships, data transformation plays an important role, helping us to dig deeper and wider and thus telling a better story from data. As a result, we want share some useful methods of data transformation to let you play with data more efficiently. Specifically, we want to provide a detailed instruction of package dplyr. We hope that you can know the various methods in changing the data frame and function in selecting the data which you want after reading this article. 3.2 Basics As said before, we will mainly use dplyr package, which will be automatically installed if you install the tidyverse. filter: select observations by their values arrange: reorder observations select: pick variables by their names mutate: create or rename variables summarize: aggregate observations group_by: group observations by variables All dplyr “verbs” are functions that take a data frame and return a data frame after the operation To explore the basic data manipulation of dplur, we will demonstrate using nycflights13::flights. It’s a dataset which contains information of 336,776 flights that departed from New York City in 2013. You can access it by installing the packages ‘nycflights13’. library(tidyverse) library(nycflights13) nycflights13::flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.3 Function Usage 3.3.1 1. Filter( ) To select observations we can use filter: filter (.data, condition1, condition2, …, conditionN) where each condition evaluates to a logical vector and only TRUE entries are kept. Example: we want to focus on the flight whose carrier is UA. UA_flight &lt;- filter(flights,carrier==&#39;UA&#39;) head(UA_flight) ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 554 558 -4 740 728 ## 4 2013 1 1 558 600 -2 924 917 ## 5 2013 1 1 558 600 -2 923 937 ## 6 2013 1 1 559 600 -1 854 902 ## # … with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; UA_num = nrow(UA_flight) What we found: There are UA_num, 58665, flights whose carrier is UA in nycflights13 dataset. We also can use filter to remove rows that associated with NA values of certain variables like dep_time. Tidy_flight&lt;-filter(flights,!is.na(dep_time)) dep_num = nrow(Tidy_flight) What we found: we remove over 8,000 rows whose dep_time is NA. The total number of observations after removing the NA objects in dep_time is dep_num, which is 328521. More importantly, we can cooperate with logical operators ! (not), | (or), &amp; (and) and some statistical rules such as De Morgan’s Law, to add more conditions in the filter function in a way you like. Below three approaches are equivalent to find flights in January and Feburary. filter(flights, month == 1 | month == 2) ## # A tibble: 51,955 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 51,945 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, month %in% c(1, 2)) ## # A tibble: 51,955 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 51,945 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, month &lt;=2 ) ## # A tibble: 51,955 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 51,945 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.3.1.1 More exercises: Find flights that: Were delayed by at least an hour, but made up over 30 minutes in flight filter(flights, dep_delay &gt; 60, dep_delay - arr_delay &gt;= 30) ## # A tibble: 2,046 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 1716 1545 91 2140 2039 ## 2 2013 1 1 2205 1720 285 46 2040 ## 3 2013 1 1 2326 2130 116 131 18 ## 4 2013 1 3 1503 1221 162 1803 1555 ## 5 2013 1 3 1821 1530 171 2131 1910 ## 6 2013 1 3 1839 1700 99 2056 1950 ## 7 2013 1 3 1850 1745 65 2148 2120 ## 8 2013 1 3 1923 1815 68 2036 1958 ## 9 2013 1 3 1941 1759 102 2246 2139 ## 10 2013 1 3 1950 1845 65 2228 2227 ## # … with 2,036 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Flew to Boston operated by United, American or Delta in Summer (June to August) filter(flights, dest == &quot;BOS&quot;, carrier == &quot;UA&quot; | carrier == &quot;AA&quot; | carrier == &quot;DL&quot;, month %in% c(6, 7, 8)) ## # A tibble: 1,663 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 6 1 816 820 -4 920 930 ## 2 2013 6 1 1022 1025 -3 1130 1150 ## 3 2013 6 1 1240 1245 -5 1343 1350 ## 4 2013 6 1 1519 1530 -11 1705 1702 ## 5 2013 6 1 1524 1445 39 1634 1615 ## 6 2013 6 1 1555 1600 -5 1705 1720 ## 7 2013 6 1 1954 1955 -1 2116 2110 ## 8 2013 6 1 2010 2000 10 2115 2130 ## 9 2013 6 1 2124 2125 -1 2224 2256 ## 10 2013 6 1 2152 2159 -7 2252 2328 ## # … with 1,653 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.3.2 2. Arrange( ) Arrange( ) function lets us to reorder the rows in a order that we want: arrange (.data, variable1, variable2,…, .by_group = FALSE) It’s default in increasing order. To reorder decreasingly, use desc. You can also reorder the rows by group, using .by_group. Example: we can reorder the flight by the delay in departure in a increasing order. arrange(flights, dep_delay) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 12 7 2040 2123 -43 40 2352 ## 2 2013 2 3 2022 2055 -33 2240 2338 ## 3 2013 11 10 1408 1440 -32 1549 1559 ## 4 2013 1 11 1900 1930 -30 2233 2243 ## 5 2013 1 29 1703 1730 -27 1947 1957 ## 6 2013 8 9 729 755 -26 1002 955 ## 7 2013 10 23 1907 1932 -25 2143 2143 ## 8 2013 3 30 2030 2055 -25 2213 2250 ## 9 2013 3 2 1431 1455 -24 1601 1631 ## 10 2013 5 5 934 958 -24 1225 1309 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; What we found: The data has been reorder by dep_delay value from small to large. we can reorder the flight by the delay in departure in a decreasing order. arrange(flights, desc(dep_delay)) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 9 641 900 1301 1242 1530 ## 2 2013 6 15 1432 1935 1137 1607 2120 ## 3 2013 1 10 1121 1635 1126 1239 1810 ## 4 2013 9 20 1139 1845 1014 1457 2210 ## 5 2013 7 22 845 1600 1005 1044 1815 ## 6 2013 4 10 1100 1900 960 1342 2211 ## 7 2013 3 17 2321 810 911 135 1020 ## 8 2013 6 27 959 1900 899 1236 2226 ## 9 2013 7 22 2257 759 898 121 1026 ## 10 2013 12 5 756 1700 896 1058 2020 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; What we found: The data has been reorder by dep_delay value from large to small. we can reorder the flight by the month and day. arrange(flights, month, day) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; What we found: The data has been reorder by 2 variables: month and day. For the object with same month, they are reordering by day. we can reorder the flight by the delay in departure in a decreasing order group by carrier. flights%&gt;%group_by(carrier)%&gt;%arrange(desc(dep_delay),.by_group = TRUE) ## # A tibble: 336,776 x 19 ## # Groups: carrier [16] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 2 16 757 1930 747 1013 2149 ## 2 2013 7 24 1525 815 430 1808 1030 ## 3 2013 11 27 1503 815 408 1628 952 ## 4 2013 2 27 1529 845 404 1639 1015 ## 5 2013 7 7 2228 1559 389 NA 1828 ## 6 2013 6 25 1421 805 376 1602 950 ## 7 2013 1 25 15 1815 360 208 1958 ## 8 2013 12 14 1425 825 360 1604 938 ## 9 2013 9 12 2159 1600 359 2400 1818 ## 10 2013 7 22 2216 1620 356 116 1853 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; What we found: The data has been reorder by grouping the carrier and then order by dep_delay value from large to small. Since the carrier is nominal variable, the carrier order is default. Attention: If we don’t use the .by_group in arrange( ), the data will be reorder just by dep_delay value although we have group_by the data in previous. 3.3.3 3. Select( ) It subsets a dataset containing only selected variables. select (.data, variable_expression) Some helper functions: Negative indices remove variables from the selection. A:B, from column A to column B starts_with(“abc”): matches names starting with “abc” ends_with(“xyz”): matches names ending with “xyz” contains(“ijk”): matches names containing “ijk” num_range(“x”, 1:3): matches x1, x2, x3 We can use the operators in selecting the variables easily and use c( ) to combine selections. Example: Select year, month, day, destination columns from flights. select(flights, year:day, dest) ## # A tibble: 336,776 x 4 ## year month day dest ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2013 1 1 IAH ## 2 2013 1 1 IAH ## 3 2013 1 1 MIA ## 4 2013 1 1 BQN ## 5 2013 1 1 ATL ## 6 2013 1 1 ORD ## 7 2013 1 1 FLL ## 8 2013 1 1 IAD ## 9 2013 1 1 MCO ## 10 2013 1 1 ORD ## # … with 336,766 more rows we can also use the columns number to represent the columns name. select(flights, 1:3, 14) ## # A tibble: 336,776 x 4 ## year month day dest ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2013 1 1 IAH ## 2 2013 1 1 IAH ## 3 2013 1 1 MIA ## 4 2013 1 1 BQN ## 5 2013 1 1 ATL ## 6 2013 1 1 ORD ## 7 2013 1 1 FLL ## 8 2013 1 1 IAD ## 9 2013 1 1 MCO ## 10 2013 1 1 ORD ## # … with 336,766 more rows we can also use | to union the variable set. select(flights, 1:3|14) ## # A tibble: 336,776 x 4 ## year month day dest ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2013 1 1 IAH ## 2 2013 1 1 IAH ## 3 2013 1 1 MIA ## 4 2013 1 1 BQN ## 5 2013 1 1 ATL ## 6 2013 1 1 ORD ## 7 2013 1 1 FLL ## 8 2013 1 1 IAD ## 9 2013 1 1 MCO ## 10 2013 1 1 ORD ## # … with 336,766 more rows Select all columns except year, month, day, destination from flights. select(flights, !year:day, !dest) ## # A tibble: 336,776 x 19 ## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA ## 2 533 529 4 850 830 20 UA ## 3 542 540 2 923 850 33 AA ## 4 544 545 -1 1004 1022 -18 B6 ## 5 554 600 -6 812 837 -25 DL ## 6 554 558 -4 740 728 12 UA ## 7 555 600 -5 913 854 19 B6 ## 8 557 600 -3 709 723 -14 EV ## 9 557 600 -3 838 846 -8 B6 ## 10 558 600 -2 753 745 8 AA ## # … with 336,766 more rows, and 12 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt; We can also use the c( ) to combine the variables. select(flights, !c(year:day,dest)) ## # A tibble: 336,776 x 15 ## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA ## 2 533 529 4 850 830 20 UA ## 3 542 540 2 923 850 33 AA ## 4 544 545 -1 1004 1022 -18 B6 ## 5 554 600 -6 812 837 -25 DL ## 6 554 558 -4 740 728 12 UA ## 7 555 600 -5 913 854 19 B6 ## 8 557 600 -3 709 723 -14 EV ## 9 557 600 -3 838 846 -8 B6 ## 10 558 600 -2 753 745 8 AA ## # … with 336,766 more rows, and 8 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Select columns end with ‘times’. select(flights, ends_with(&quot;time&quot;)) ## # A tibble: 336,776 x 5 ## dep_time sched_dep_time arr_time sched_arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 830 819 227 ## 2 533 529 850 830 227 ## 3 542 540 923 850 160 ## 4 544 545 1004 1022 183 ## 5 554 600 812 837 116 ## 6 554 558 740 728 150 ## 7 555 600 913 854 158 ## 8 557 600 709 723 53 ## 9 557 600 838 846 140 ## 10 558 600 753 745 138 ## # … with 336,766 more rows Select columns end with ‘times’ but without the one starting with ‘sched’. select(flights, ends_with(&quot;time&quot;), -starts_with(&quot;sched&quot;)) ## # A tibble: 336,776 x 3 ## dep_time arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 830 227 ## 2 533 850 227 ## 3 542 923 160 ## 4 544 1004 183 ## 5 554 812 116 ## 6 554 740 150 ## 7 555 913 158 ## 8 557 709 53 ## 9 557 838 140 ## 10 558 753 138 ## # … with 336,766 more rows Select columns contains ‘dep’. select(flights, contains(&quot;dep&quot;)) ## # A tibble: 336,776 x 3 ## dep_time sched_dep_time dep_delay ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 2 ## 2 533 529 4 ## 3 542 540 2 ## 4 544 545 -1 ## 5 554 600 -6 ## 6 554 558 -4 ## 7 555 600 -5 ## 8 557 600 -3 ## 9 557 600 -3 ## 10 558 600 -2 ## # … with 336,766 more rows Select year, month, day, destination columns from flights. Also columns end with ‘times’ but without the one starting with ‘sched’. select(flights, year:day, dest, ends_with(&quot;time&quot;), -starts_with(&quot;sched&quot;)) ## # A tibble: 336,776 x 7 ## year month day dest dep_time arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 IAH 517 830 227 ## 2 2013 1 1 IAH 533 850 227 ## 3 2013 1 1 MIA 542 923 160 ## 4 2013 1 1 BQN 544 1004 183 ## 5 2013 1 1 ATL 554 812 116 ## 6 2013 1 1 ORD 554 740 150 ## 7 2013 1 1 FLL 555 913 158 ## 8 2013 1 1 IAD 557 709 53 ## 9 2013 1 1 MCO 557 838 140 ## 10 2013 1 1 ORD 558 753 138 ## # … with 336,766 more rows Attention: For without condition, we can also use ! to replace the -. We can also use &amp; to intersect the variables set together, which is equivalent with the previous method. select(flights, year:day, dest, ends_with(&quot;time&quot;)&amp; -starts_with(&quot;sched&quot;)) ## # A tibble: 336,776 x 7 ## year month day dest dep_time arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 IAH 517 830 227 ## 2 2013 1 1 IAH 533 850 227 ## 3 2013 1 1 MIA 542 923 160 ## 4 2013 1 1 BQN 544 1004 183 ## 5 2013 1 1 ATL 554 812 116 ## 6 2013 1 1 ORD 554 740 150 ## 7 2013 1 1 FLL 555 913 158 ## 8 2013 1 1 IAD 557 709 53 ## 9 2013 1 1 MCO 557 838 140 ## 10 2013 1 1 ORD 558 753 138 ## # … with 336,766 more rows This is an example of using operations in select( ). It also approaches to the same result as before. select(flights, year:day|dest|ends_with(&quot;time&quot;)&amp;!starts_with(&quot;sched&quot;)) ## # A tibble: 336,776 x 7 ## year month day dest dep_time arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 IAH 517 830 227 ## 2 2013 1 1 IAH 533 850 227 ## 3 2013 1 1 MIA 542 923 160 ## 4 2013 1 1 BQN 544 1004 183 ## 5 2013 1 1 ATL 554 812 116 ## 6 2013 1 1 ORD 554 740 150 ## 7 2013 1 1 FLL 555 913 158 ## 8 2013 1 1 IAD 557 709 53 ## 9 2013 1 1 MCO 557 838 140 ## 10 2013 1 1 ORD 558 753 138 ## # … with 336,766 more rows 3.3.4 4. Mutate( ) It changes variables to the format that we want. If we want to only keep the variables that we create, we should use transmute( ) mutate (.data,…, .keep = c(“all”, “used”, “unused”, “none”), .before = NULL, .after = NULL) Some helper functions： Arithmetic operators: +, -, *, /, ^, %/% (integer division), and %% (remainder) Mathematical functions such as log, exp, sin, cos, and others Logical operators, e.g. !=, |, as we saw when discussing filter Offsets: lead and lag, e.g., to compute running difference x - lag(x) Aggregators: mean, sum, min, max and their respective cummulators cummean, cumsum, cummin, cummax Example: We create three variables here: gain which measures in-flight time gain, duration which is flight duration in hours and speed which equals to distance divided by duration. mutate(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration) ## # A tibble: 336,776 x 22 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 14 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, ## # gain &lt;dbl&gt;, duration &lt;dbl&gt;, speed &lt;dbl&gt; Attention: Since the default value of .keep = “all”, we will get a new data frame with all variables and new variables. we can also use .keep = “used” to get the data frame contain the new variables and variables we used in generate the new variables. mutate(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration, .keep = &quot;used&quot;) ## # A tibble: 336,776 x 7 ## dep_delay arr_delay air_time distance gain duration speed ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 11 227 1400 -9 3.78 370. ## 2 4 20 227 1416 -16 3.78 374. ## 3 2 33 160 1089 -31 2.67 408. ## 4 -1 -18 183 1576 17 3.05 517. ## 5 -6 -25 116 762 19 1.93 394. ## 6 -4 12 150 719 -16 2.5 288. ## 7 -5 19 158 1065 -24 2.63 404. ## 8 -3 -14 53 229 11 0.883 259. ## 9 -3 -8 140 944 5 2.33 405. ## 10 -2 8 138 733 -10 2.3 319. ## # … with 336,766 more rows we can also use .keep = “unused” to get the data frame contain the new variables and all variables which don’t used in calulate the new variables. This transform is equal to replace the variables using new variable related to it in this data frame. mutate(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration, .keep = &quot;unused&quot;) ## # A tibble: 336,776 x 18 ## year month day dep_time sched_dep_time arr_time sched_arr_time carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2013 1 1 517 515 830 819 UA ## 2 2013 1 1 533 529 850 830 UA ## 3 2013 1 1 542 540 923 850 AA ## 4 2013 1 1 544 545 1004 1022 B6 ## 5 2013 1 1 554 600 812 837 DL ## 6 2013 1 1 554 558 740 728 UA ## 7 2013 1 1 555 600 913 854 B6 ## 8 2013 1 1 557 600 709 723 EV ## 9 2013 1 1 557 600 838 846 B6 ## 10 2013 1 1 558 600 753 745 AA ## # … with 336,766 more rows, and 10 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, ## # gain &lt;dbl&gt;, duration &lt;dbl&gt;, speed &lt;dbl&gt; we can also use .keep = “none” to get the data frame only contain the new variables. This transform is same as using default transmute. mutate(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration, .keep = &quot;none&quot;) ## # A tibble: 336,776 x 3 ## gain duration speed ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -9 3.78 370. ## 2 -16 3.78 374. ## 3 -31 2.67 408. ## 4 17 3.05 517. ## 5 19 1.93 394. ## 6 -16 2.5 288. ## 7 -24 2.63 404. ## 8 11 0.883 259. ## 9 5 2.33 405. ## 10 -10 2.3 319. ## # … with 336,766 more rows transmute(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration) ## # A tibble: 336,776 x 3 ## gain duration speed ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -9 3.78 370. ## 2 -16 3.78 374. ## 3 -31 2.67 408. ## 4 17 3.05 517. ## 5 19 1.93 394. ## 6 -16 2.5 288. ## 7 -24 2.63 404. ## 8 11 0.883 259. ## 9 5 2.33 405. ## 10 -10 2.3 319. ## # … with 336,766 more rows Attention: The difference between Mutate( ) and Transmute( ) is that: the default return from Mutate( ) are all variables with new variables. However, the default return from transmute( ) is only the new variables. We can change the parameter in each functions and get the same result. We create a new boolean variable as_scheduled which indicates whether the flight delays in arrival time or departure time. And we use transmute here to only keep three variables, including the one we just created. flights %&gt;% transmute(arr_delay, dep_delay, as_scheduled = arr_delay &lt; 0 &amp; dep_delay &lt; 0) ## # A tibble: 336,776 x 3 ## arr_delay dep_delay as_scheduled ## &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 11 2 FALSE ## 2 20 4 FALSE ## 3 33 2 FALSE ## 4 -18 -1 TRUE ## 5 -25 -6 TRUE ## 6 12 -4 FALSE ## 7 19 -5 FALSE ## 8 -14 -3 TRUE ## 9 -8 -3 TRUE ## 10 8 -2 FALSE ## # … with 336,766 more rows We use .before and .after to determine the position of new variables. Create three variables here: gain which measures in-flight time gain, duration which is flight duration in hours and speed which equals to distance divided by duration. Then we want to place the variables in front of dep_time. mutate(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration, .before = dep_time) ## # A tibble: 336,776 x 22 ## year month day gain duration speed dep_time sched_dep_time dep_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 -9 3.78 370. 517 515 2 ## 2 2013 1 1 -16 3.78 374. 533 529 4 ## 3 2013 1 1 -31 2.67 408. 542 540 2 ## 4 2013 1 1 17 3.05 517. 544 545 -1 ## 5 2013 1 1 19 1.93 394. 554 600 -6 ## 6 2013 1 1 -16 2.5 288. 554 558 -4 ## 7 2013 1 1 -24 2.63 404. 555 600 -5 ## 8 2013 1 1 11 0.883 259. 557 600 -3 ## 9 2013 1 1 5 2.33 405. 557 600 -3 ## 10 2013 1 1 -10 2.3 319. 558 600 -2 ## # … with 336,766 more rows, and 13 more variables: arr_time &lt;int&gt;, ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; We create three variables here: gain which measures in-flight time gain, duration which is flight duration in hours and speed which equals to distance divided by duration. Then we want to place the variables in after of dep_time. mutate(flights,gain = dep_delay - arr_delay, duration = air_time / 60, speed = distance / duration, .after = dep_time) ## # A tibble: 336,776 x 22 ## year month day dep_time gain duration speed sched_dep_time dep_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 517 -9 3.78 370. 515 2 ## 2 2013 1 1 533 -16 3.78 374. 529 4 ## 3 2013 1 1 542 -31 2.67 408. 540 2 ## 4 2013 1 1 544 17 3.05 517. 545 -1 ## 5 2013 1 1 554 19 1.93 394. 600 -6 ## 6 2013 1 1 554 -16 2.5 288. 558 -4 ## 7 2013 1 1 555 -24 2.63 404. 600 -5 ## 8 2013 1 1 557 11 0.883 259. 600 -3 ## 9 2013 1 1 557 5 2.33 405. 600 -3 ## 10 2013 1 1 558 -10 2.3 319. 600 -2 ## # … with 336,766 more rows, and 13 more variables: arr_time &lt;int&gt;, ## # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.3.5 5. Group_by( ) and Summarize( ) Summarize( ) is used to aggregated data. We usually use it after grouping the observations with group_by. In other words, when we want to know counts of certain combinations of variables, we can take advantage of group_by and summarize. (Hint: summarise () is the same as summarize( )). Examples: For each original airports, find their median delay time and associated counts. na.rm = TRUE: remove missing values summarize(group_by(flights, origin),median_delay = median(arr_delay, na.rm = TRUE), count = n()) ## # A tibble: 3 x 3 ## origin median_delay count ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 EWR -4 120835 ## 2 JFK -6 111279 ## 3 LGA -5 104662 For each original airports and each carriers, find the proportion of flights that had a delayed departure, but by no longer than 30 minutes. summarize(group_by(flights, origin, carrier), prop_delayed = mean(between(dep_delay, 0, 30), na.rm = TRUE)) ## # A tibble: 35 x 3 ## # Groups: origin [3] ## origin carrier prop_delayed ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 EWR 9E 0.134 ## 2 EWR AA 0.214 ## 3 EWR AS 0.268 ## 4 EWR B6 0.236 ## 5 EWR DL 0.240 ## 6 EWR EV 0.264 ## 7 EWR MQ 0.245 ## 8 EWR OO 0.333 ## 9 EWR UA 0.422 ## 10 EWR US 0.183 ## # … with 25 more rows We can also use group_by in front of summarize. flights %&gt;% group_by(origin, carrier) %&gt;% summarize(prop_delayed = mean(between(dep_delay, 0, 30), na.rm = TRUE)) ## # A tibble: 35 x 3 ## # Groups: origin [3] ## origin carrier prop_delayed ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 EWR 9E 0.134 ## 2 EWR AA 0.214 ## 3 EWR AS 0.268 ## 4 EWR B6 0.236 ## 5 EWR DL 0.240 ## 6 EWR EV 0.264 ## 7 EWR MQ 0.245 ## 8 EWR OO 0.333 ## 9 EWR UA 0.422 ## 10 EWR US 0.183 ## # … with 25 more rows 3.4 Quick EDA: median arrival delays Here, we utilize the tools of dyplr to conduct a quick exploratory data analysis of median arrival delays of flights. First, we clean the dataset a little bit by filtering out the flights whose arr_delay and dep_delay is NA. Therefore, we can find flights that are not cancelled and then it’s meaningful to analyze their arrival delay. not_canceled &lt;- flights %&gt;% filter(!is.na(arr_delay), !is.na(dep_delay)) Then, we want to see if the arrival delays of flights are different at each airport, so we use group_by( ) and summarise( ) to get a basic statistics summary of arrival delays.Here, we display counts, min, 25th quantile, median, 75th quantile and max of arrival delays. not_canceled %&gt;% group_by(origin) %&gt;% summarize(count = n(),min_delay = min(arr_delay), q1_delay = quantile(arr_delay, .25), # first quartile median_delay = median(arr_delay), q3_delay = quantile(arr_delay, .75), # third quartile max_delay = max(arr_delay)) ## # A tibble: 3 x 7 ## origin count min_delay q1_delay median_delay q3_delay max_delay ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 117127 -86 -16 -4 16 1109 ## 2 JFK 109079 -79 -18 -6 13 1272 ## 3 LGA 101140 -68 -17 -5 12 915 Through the summary, we discover that the flights distributes pretty evenly in three airports, which avoids selection bias affecting our analysis negatively. Also, EWR has highest median delay and LGA has the lowest one. But, we have to say that the differences of median delay at three airpots don’t seem to be very significant, which suggests that the arrival delay may not depend on the airports. Then, we want to see if the arrival delay depends on the flight. Thus, let us plot histogram median arrival delay for each flight: plot_theme&lt;-theme(panel.grid.major.y = element_line(), panel.grid.major.x = element_line(), panel.grid.minor = element_line(), plot.background = element_rect(fill=&#39;#FAFAFA&#39;), axis.line = element_line(color=&#39;black&#39;), plot.title = element_text(hjust=0.25)) not_canceled %&gt;% group_by(flight) %&gt;% summarize(delay = median(arr_delay)) %&gt;% ggplot(aes(x=delay)) + geom_histogram()+ labs(x=&#39;Median Arrival Delay&#39;, y=&#39;Frequency&#39;, title=&#39;Histogram of Median Arrival Delay of each flight&#39;)+ plot_theme We discover that most flights’ median arrival delay is around 10,while only a very few number of flights have median arrival delay around 75 to 90 minutes.And one or two flights even have median delay over 200 miniutes. Now let’s plot median arrival delay against number of trips for flight: not_canceled %&gt;% group_by(flight) %&gt;% summarize(count = n(), delay = median(arr_delay)) %&gt;% ggplot(aes(x = count, y = delay)) + geom_point(alpha = 0.1)+ labs(x=&#39;Number of trips&#39;,y=&#39;median arrival delay&#39;,title=&#39;Median Arrival Delay V.s Number of trips&#39;)+ plot_theme Like the previous plot, we notice that the “outliers” seem to be due to flights with small number of trips. Probably, we should remove them and take a closer look at ones that have more than 25 trips. We also add a regression line with a smoother, hoping to indicate something about relationship between median arrival delay and number of trips of flights. not_canceled %&gt;% group_by(flight) %&gt;% summarize(count = n(), delay = median(arr_delay)) %&gt;% filter(count &gt; 25) %&gt;% ggplot(aes(x = count, y = delay)) + geom_point(alpha = .1) + geom_smooth()+ plot_theme In the plot, we find a very weak negative relationship between number of trips and median arrival delay. 3.5 External Resource dplyr: Excellent resource about the overview of dplyr package. Linking to URL in markdown and R markdown Cheatsheet: Tools to typeset in markdown. "],["customized-plot-matrix-pairs-and-ggpairs.html", "Chapter 4 Customized Plot Matrix: pairs and ggpairs 4.1 Overview: Things we can do with pairs() and ggpairs() 4.2 Scatterplot matrix for continuous variables 4.3 Categorical variables 4.4 Outside sources", " Chapter 4 Customized Plot Matrix: pairs and ggpairs Yibai Liu library(GGally) library(ggplot2) library(vcd) 4.1 Overview: Things we can do with pairs() and ggpairs() When our data contains multivariate variables, it is important to evaluate associations between these variables before modeling. We can create scatterplot matrices, correlation matrix, as well as mosaic pairs plots to get an idea about if and how these variables are correlated with each other. In this tutorial, I would plot using a base r function pairs() and a function ggpairs() from the GGally package, which both functions provide methods to generate customized plot matrices. Plots for different purposes: - Scatterplot matrix: correlations between continuous variables - Mosaic pairs plot: correlations between categorical variables 4.2 Scatterplot matrix for continuous variables 4.2.1 Plot with pairs() 4.2.1.1 Basic scatterplot matrix of the `mtcars dataset (all numeric variables) data(mtcars) pairs(~., data = mtcars, main = &quot;Scatterplot Matrix of `mtcars`&quot;) We notice that there are some numeric variables actually discrete or representing categories, so we can trim all discrete and categorical variables, and only plot continuous variables in the matrix. 4.2.1.2 Continuous variables only pairs(mtcars[, c(1,3:7)], main = &quot;Scatterplot Matrix of `mtcars`&quot;) 4.2.1.3 Change color, shape, size of points, as well as labels and gaps of the plot pairs(mtcars[, c(1,3:7)], col = &quot;blue&quot;, # Change color pch = 19, # Change shape of points cex = 0.8, # Change size of points labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), # Change labels gap = 0.3, # Change gaps in between main = &quot;Scatterplot Matrix of `mtcars`&quot;) 4.2.1.4 Add a smoother to each scatterplot pairs(mtcars[, c(1,3:7)], lower.panel = panel.smooth, # Add a smoother for the lower panel col = &quot;blue&quot;, pch = 19, cex = 0.8, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, main = &quot;Scatterplot Matrix of `mtcars`&quot;) 4.2.1.5 Separate groups using different colors Tip: You can also highlight a certain level of a categorical variable by simply turn other levels to grey. mtcars$vs &lt;- as.factor(mtcars$vs) pairs(mtcars[, c(1,3:7)], col = c(&quot;blue&quot;,&quot;red&quot;)[mtcars$vs], # Group by variable `vs` pch = 19, cex = 0.8, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, main = &quot;Scatterplot Matrix of `mtcars` Grouped by Engine&quot;) By separating data points by vs or the engine type, we can see that two groups form distinct clusters for many of the variables. 4.2.1.6 Choose panel display If the plot seems dominated by too many points, you can turn off one of the panels. pairs(mtcars[, c(1,3:7)], col = c(&quot;blue&quot;,&quot;red&quot;)[mtcars$vs], pch = 19, cex = 0.8, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, upper.panel = NULL, # Turn off the upper panel above the diagonal main = &quot;Scatterplot Matrix of `mtcars`&quot;) 4.2.1.7 Customize your own plot matrix The plot matrix is consisted of multiple panels, e.g. the upper panel, lower panel, diagonal panel, etc. You can customize each panel and make your own plot. #Panel of correlations panel.corr &lt;- function(x, y){ usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(0, 1, 0, 1)) r &lt;- round(cor(x, y), digits=3) txt &lt;- paste0(&quot;Corr: &quot;, r) text(0.5, 0.5, txt, cex = 1) } #Panel of histograms panel.hist &lt;- function(x, ...){ usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(usr[1:2], 0, 1.5) ) h &lt;- hist(x, plot = FALSE) breaks &lt;- h$breaks len &lt;- length(breaks) y &lt;- h$counts/max(h$counts) rect(breaks[-len], 0, breaks[-1], y, col = &quot;lightblue&quot;) } #Panel of scatterplots panel.scat &lt;- function(x, y){ points(x,y, pch = 19, cex = 1, col = &quot;coral&quot;) } #Plot pairs(mtcars[, c(1,3:7)], lower.panel = panel.scat, upper.panel = panel.corr, diag.panel = panel.hist, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, main = &quot;Scatterplot matrix of `mtcars`&quot;) 4.2.2 Plot with ggpairs() from GGally package 4.2.2.1 Basic ggpairs() plot # You need both ggplot2 and GGally packages loaded to use ggpairs() ggpairs(mtcars[, c(1,3:7)], columnLabels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), upper = list(continuous = wrap(&#39;cor&#39;, size = 4)), title = &quot;Scatterplot matrix of `mtcars`&quot;) 4.2.2.2 Separate groups using different colors ggpairs(mtcars[, c(1,3:7)], columnLabels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), aes(color = mtcars$vs), # Separate data by levels of vs upper = list(continuous = wrap(&#39;cor&#39;, size = 3)), lower = list(combo = wrap(&quot;facethist&quot;, bins = 30)), diag = list(continuous = wrap(&quot;densityDiag&quot;, alpha = 0.5)), title = &quot;Scatterplot matrix of `mtcars` Grouped by Engine&quot;) 4.3 Categorical variables There are some categorical variables in the dataset mtcars. We can turn these variables and also discrete variables into factors ### Factorize discrete/categorical variables mtcars$cyl &lt;- as.factor(mtcars$cyl) mtcars$am &lt;- as.factor(mtcars$am) mtcars$gear &lt;- as.factor(mtcars$gear) Now we can create a mosaic pairs plot with pairs_diagonal_mosaic() in the vcd package 4.3.1 pairs() plot for categorical variables # You need to load the `vcd` package p &lt;- mtcars[, c(2,8:10)] pairs(table(p), # Here the data needs to be in a table format diag_panel = pairs_diagonal_mosaic(offset_varnames=-2.5)) #move down variable labels 4.3.2 Highlight correlations with shade colors pairs(table(p), diag_panel = pairs_diagonal_mosaic(offset_varnames=-2.5), #move down variable names upper_panel_args = list(shade = TRUE), #set shade colors lower_panel_args = list(shade = TRUE)) 4.4 Outside sources You can check out the following links to find more interesting ways to customize your plot matrix. [R pairs &amp; ggpairs Plot Functions] https://statisticsglobe.com/r-pairs-plot-example/#:~:text=The%20pairs%20R%20function%20returns,pairs%20command%20is%20shown%20above. [ggpairs() r documentation] https://www.rdocumentation.org/packages/GGally/versions/1.5.0/topics/ggpairs [Pairs plot for contingency tables] http://finzi.psych.upenn.edu/R/library/vcd/html/pairs.table.html "],["a-brief-introduction-to-seaborn.html", "Chapter 5 A brief introduction to seaborn", " Chapter 5 A brief introduction to seaborn Rui Qin In the class, we learned how to create graphs of data by ggplot2, a data visualization package in R. Likewise, there are some libraries in Python able to do the same job as ggplot2. Seaborn is a data visualization tool based on Python library, matplotlib. Like ggplot2 in R, seaborn can create multiple kinds of statistical graphs for exploratory and explanatory purpose. In this file I will show some examples of graphs that we have learned in class and I will use three languages, English, Chinese, and Japanese, to briefly explain them. 课上，我们学习并掌握了R语言中通过ggplot2绘制统计图表。Python中也有同样的数据可视化库包括matplotlib和seaborn。他们均可以将数据框中的数据以图标的形式表现出来，以此达到数据分析的目的。这里我将用seaborn展示几组课上学过的常用图表绘制方法。 クラスでggplot2とRを利用し、統計グラフを作るのが勉強しました。同様に、Pythonのデータ可視化ライブラリもあります。よく使われるのはmatplotlibとseabornです。ggplot2のように、seabornは色々な統計グラフを作れます。これから、私はseabornの使い方を説明したいと思います。 Here is the link! "],["webscraping-dynamic-content-rselenium-tutorial.html", "Chapter 6 Webscraping Dynamic Content: Rselenium Tutorial 6.1 Introduction and Setup 6.2 Simple Illustrations with Websites 6.3 Other Features", " Chapter 6 Webscraping Dynamic Content: Rselenium Tutorial Chenchao You 6.1 Introduction and Setup This is a tutorial on webscrapping dynamic content with the help of RSelenium. In previous courses we have learned how to use rvest to webscrap html pages. Specifically, recall that in problem set 2 we are asked to webscrape “https://www.metacritic.com/publication/digital-trends” to gather information about metascores, using rvest package and SelectorGadget. metacritic &lt;- read_html(&quot;https://www.metacritic.com/publication/digital-trends&quot;) title_html &lt;- html_nodes(metacritic,&#39;.review_product a&#39;) title_data &lt;- html_text(title_html) meta_html &lt;- html_nodes(metacritic,&#39;.brief_metascore .game&#39;) meta_score &lt;- html_text(meta_html) crit_html &lt;- html_nodes(metacritic,&#39;.brief_critscore .indiv&#39;) crit_score &lt;- html_text(crit_html) This webpage is not dynamic so we could scrape the content by identifying CSS component using SelectorGadget and extract the data from html with rvest. However, most of the modern website use dynamic content. An example of this is Linkedin or Twitter. When you scroll down the webpage, new content is loaded without changing the URL. What if say, we want to webscrape Donald Trump’s Twitter information? Preparations First you need to make sure you have a working environment. That includes the corresponding R packages, a working JAVA environment installed on your OS, and a installed browser. In this tutorial I’ll use chrome version “86.0.4240.22” as the browser. install.packages(&quot;RSelenium&quot;) install.packages(&quot;rvest&quot;) install.packages(&quot;tidyverse&quot;) After the environment is properly set, we can proceed to initialize our browser. rD &lt;- rsDriver(browser=&quot;chrome&quot;, chromever=&quot;86.0.4240.22&quot;, verbose=T) remDr &lt;- rD[[&quot;client&quot;]] Some common error messages include port occupied or failed to receive handshake. Either try resetting connection with system(&quot;taskkill /im java.exe /f&quot;, intern=FALSE, ignore.stdout=FALSE) or use VPN in the internet connection. If everything is setup correctly, you should see a browser popping up. Now you are ready to navigate dynamic pages using RSelenium. 6.2 Simple Illustrations with Websites We will use “https://www.google.com” as a simple example to use some Rselenium functions. To navigate to google webpage: remDr$navigate(&quot;https://www.google.com&quot;) Rselenium use HTML, CSS or XPath to find which object to operate on. More information on the locator strategies for webdrivers can be found on https://stackoverflow.com/questions/48369043/official-locator-strategies-for-the-webdriver/48376890#48376890. However for the time being, we only need to understand some simple locator techniques. Some common locators include: id, name, css selector, xpath To find information about the target object (in our example the google search text input box), right click and select inspect: We spot name=‘q’ to locate the target object. In this case use $findElement function to select the textbox and use sendKeysToElement to input the text you want input &lt;- &quot;edav&quot; selected &lt;- remDr$findElement(using = &quot;name&quot;, value = &quot;q&quot;) selected$sendKeysToElement(list(input)) Next we want to click the search button to search EDAV on google. Again use Inspect to locate the button object, and we found name=‘btnK’ to locate our button remDr$findElements(&quot;name&quot;, &quot;btnK&quot;)[[1]]$clickElement() Now we have the search result of EDAV. To scroll up or down the webpage, select the entire webpage using: webpage &lt;- remDr$findElement(&quot;css&quot;, &quot;body&quot;) 6.3 Other Features Rselenium can simulate shortcut keys of the browser. selKeys function gives the list of shortcut keys. selKeys We can use: home, end, up_arrow, or down_arrow to navigate the webpage webpage$sendKeysToElement(list(key = &quot;home&quot;)) webpage$sendKeysToElement(list(key = &quot;end&quot;)) webpage$sendKeysToElement(list(key = &quot;up_arrow&quot;)) webpage$sendKeysToElement(list(key = &quot;down_arrow&quot;)) Read HTML After using RSelenium to get the webpage in the form we want, we can extract html using command $getPageSource(). Remember to give page time to fully load if your internet connection is poor. Sys.sleep(3) html &lt;- remDr$getPageSource()[[1]] This html object can then be processed by all the rvest tools we have learned earlier. More information on rvest can be found on https://github.com/tidyverse/rvest if you are not familiar with this tool already. Summary RSelenium provides R bindings for the Selenium Webdriver, which is a powerful tool for automated web browsers. We have only covered a few simple functions in this tutorial. To realize the full potential of this package, we encourage the reader to explore the documentation of RSelenium on https://cran.r-project.org/web/packages/RSelenium/vignettes/basics.html. Background knowledge of HTML and CSS are also super helpful in the webscraping process. "],["china-choropleth-map.html", "Chapter 7 China choropleth map 7.1 Overview 7.2 Data Collection 7.3 Static Map with ggplot 7.4 Interactive Map with hchinamap 7.5 Interactive Map with leafletCN 7.6 Conclusion", " Chapter 7 China choropleth map Jialu Xia and Danyang Han library(jsonlite) library(tidyverse) library(hash) library(ggplot2) library(maptools) library(tidyr) library(rgdal) library(here) library(hchinamap) library(magrittr) library(data.table) library(mapproj) library(shadowtext) library(leafletCN) 7.1 Overview From a choropleth map of Covid-19 spread, we could clearly see the number of confirmed cases and severity in each area on the map. We would like to introduce some techniques to plot choropleth map with R. There are different types of maps, like the world map, maps of Continents and maps of Countries etc,. Different maps may require different packages to plot. Here we typically explore maps of China. As a running example, we collected China’s Covid-19 data and start from ggplot, a tool we learned in the lectures. In addition to this, we practiced hchinamap and leafletCN to plot interactive maps. 7.2 Data Collection We web-scarped China’s Covid-19 data. The data set includes daily updates of confirmed cases and death for each city in China. url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=1580373566110&#39; x = readLines(url, encoding=&quot;UTF-8&quot;) x = sub(&quot;^\\\\d+&quot;, &quot;&quot;, x) x = sub(&quot;^\\\\(&quot;, &quot;&quot;, x) x = sub(&quot;\\\\)$&quot;, &quot;&quot;, x) y = fromJSON(x) d = fromJSON(y$data) h = d$areaTree$children[[1]] names_dic = hash(c(&quot;香港&quot;, &quot;上海&quot;, &quot;新疆&quot;, &quot;台湾&quot;, &quot;四川&quot;, &quot;广东&quot;, &quot;陕西&quot;, &quot;福建&quot;, &quot;内蒙古&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;江苏&quot;, &quot;山东&quot;, &quot;浙江&quot;, &quot;辽宁&quot;, &quot;山西&quot;, &quot;河南&quot;, &quot;重庆&quot;, &quot;云南&quot;, &quot;北京&quot;, &quot;黑龙江&quot;, &quot;湖南&quot;, &quot;广西&quot;, &quot;宁夏&quot;, &quot;吉林&quot;, &quot;西藏&quot;, &quot;海南&quot;, &quot;澳门&quot;, &quot;江西&quot;, &quot;青海&quot;, &quot;湖北&quot;, &quot;甘肃&quot;, &quot;安徽&quot;, &quot;贵州&quot; ), c(&quot;Hongkong&quot;, &quot;Shangahi&quot;, &quot;Xinjiang&quot;, &quot;Taiwan&quot;, &quot;Sichuan&quot;, &quot;Guangdong&quot;,&quot;Shannxi&quot;, &quot;Fujian&quot;, &quot;Inner Mongolia&quot;, &quot;Tianjing&quot;, &quot;Hebei&quot;,&quot;Jiangsu&quot;, &quot;Shandong&quot;, &quot;Zhejiang&quot;, &quot;Liaoning&quot;,&quot;Shanxi&quot;, &quot;Henan&quot;, &quot;Chongqin&quot;, &quot;Yunnan&quot;, &quot;Beijing&quot;,&quot;Heilongjiang&quot;, &quot;Hunan&quot;, &quot;Guangxi&quot;,&quot;Ningxia&quot;,&quot;Jilin&quot;,&quot;Tibet&quot;,&quot;Hainan&quot;, &quot;Macao&quot;, &quot;Jiangxi&quot;,&quot;Qinghai&quot;, &quot;Hubei&quot;, &quot;Gansu&quot;, &quot;Anhui&quot; ,&quot;Guizhou&quot; ) ) name_en = values(names_dic, keys = h$name, USE.NAMES = FALSE) data = data.frame(h$name, name_en, h$total$confirm) #rename column name data&lt;-data %&gt;% rename( province_CH=h.name, province_EN=name_en, total_confirm=h.total.confirm ) data$province_CH=as.factor(data$province_CH) data$province_EN=as.factor(data$province_EN) write.csv(file=&#39;Heatmap_data.csv&#39;,data, fileEncoding = &#39;UTF-8&#39;) head(data) ## province_CH province_EN total_confirm ## 1 香港 Hongkong 5479 ## 2 上海 Shangahi 1285 ## 3 台湾 Taiwan 607 ## 4 四川 Sichuan 792 ## 5 陕西 Shannxi 487 ## 6 广东 Guangdong 1972 The dataset we use here is a 34x3 data frame: province_CH: province name in Chinese province_EN: province name in English total_confirm: total confirmed cases We are gonna plot total confirmed cases. 7.3 Static Map with ggplot Since ggplot does not have build-in China map, we download shape files from the “Capital of Statistics” webiste and prepare the shape data for ggplot. 7.3.1 Prepare the shape data of China dsn&lt;-&quot;resources/china_choropleth_map/china-province-border-data/bou2_4p.shp&quot; layer&lt;-&quot;bou2_4p&quot; china_map &lt;- rgdal::readOGR(dsn=dsn, layer=layer) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/Users/joycerobbins/cc20/resources/china_choropleth_map/china-province-border-data/bou2_4p.shp&quot;, layer: &quot;bou2_4p&quot; ## with 925 features ## It has 7 fields ## Integer64 fields read as strings: BOU2_4M_ BOU2_4M_ID ###Note: we attached external spetial data of china, named &quot;china-province-border-data&quot; and it includes &quot;bou2_4p.shp&quot; ### dsn is the path of &quot;bou2_4p.shp&quot; # extract province information from shap file china_map_data = data.table::setDT(china_map@data) data.table::setnames(china_map_data, &quot;NAME&quot;, &quot;province&quot;) # transform to UTF-8 coding format china_map_data[, province:=iconv(province, from = &quot;GBK&quot;, to = &quot;UTF-8&quot;)] # create id to join province back to lat and long, id = 0 ~ 924 china_map_data[, id:= .I-1] # id = 0, 1, 2, ... , used to match to `dt_china` # there are more shapes for one province due to small islands, extract the provinces that are consistent with our data. china_map_data[, province:= as.factor(province)] china_map_data &lt;- china_map_data[!is.na(province)] china_map_data &lt;- china_map_data[AREA &gt; 0.1] head(china_map_data, 3) ## AREA PERIMETER BOU2_4M_ BOU2_4M_ID ADCODE93 ADCODE99 province id ## 1: 54.447 68.489 2 23 230000 230000 黑龙江省 0 ## 2: 129.113 129.933 3 15 150000 150000 内蒙古自治区 1 ## 3: 175.591 84.905 4 65 650000 650000 新疆维吾尔自治区 2 dt_china = setDT(fortify(china_map)) head(dt_china, 3) ## long lat order hole piece id group ## 1: 121.4884 53.33265 1 FALSE 1 0 0.1 ## 2: 121.4995 53.33601 2 FALSE 1 0 0.1 ## 3: 121.5184 53.33919 3 FALSE 1 0 0.1 dt_china[, id:= as.numeric(id)] setkey(china_map_data, id) setkey(dt_china, id) dt_china &lt;- china_map_data[dt_china] ##adjust province names in the order of levels(china_map_data$province) so that they are compatible with plotting function re_level &lt;- function(levels){ re_level = c() for (i in 1:33) { pro = levels[i] if (grepl(&quot;黑&quot;, pro)) pro = substr(pro, start = 1, stop = 3) else if (grepl(&quot;内&quot;, pro)) pro = substr(pro, start = 1, stop = 3) else pro = substr(pro, start = 1, stop = 2) re_level[i] = pro } re_level &lt;- as.character(re_level) return(re_level) } get.centroids &lt;- function( data = dt1, long = &quot;long&quot;, lat = &quot;lat&quot;, by_var = &quot;state&quot;, # the grouping variable, e.g. state: get centroid by state fill_var = NULL # the variable to plot ){ data &lt;- data[!is.na(data[[by_var]]),] data[[by_var]] &lt;- as.character(data[[by_var]]) # sometimes there is empty factor level dt1_df &lt;- sp::SpatialPointsDataFrame(coords = data[, c(long, lat), with = FALSE], data = data) dt1_geo &lt;- by(dt1_df, dt1_df[[by_var]], function(x) {sp::Polygon(x[c(long, lat)])@labpt}) centroids &lt;- stats::setNames(do.call(&quot;rbind.data.frame&quot;, dt1_geo), c(long, lat)) centroids$name &lt;- names(dt1_geo) if(!is.null(fill_var)){ # if need to join fill value setkeyv(setDT(centroids), &quot;name&quot;) dt_var &lt;- unique(data[,c(by_var, fill_var), with = FALSE]) setkeyv(dt_var, by_var) centroids &lt;- dt_var[centroids] } return(centroids) } # combine our covid data with the shape data input_data&lt;-data %&gt;% filter(province_EN!=&quot;Macao&quot;) input_data&lt;-data.table(input_data) levels(dt_china$province) &lt;- re_level(levels(china_map_data$province)) # relevel dt_china so that it matches the level of shape file. setkey(input_data, province_CH) setkey(dt_china, province) dt_china &lt;- input_data[dt_china, nomatch = 0] centroids_cn &lt;- get.centroids(data = dt_china, by_var = &quot;province_CH&quot;) centroids_en &lt;- get.centroids(data = dt_china, by_var = &quot;province_EN&quot;) 7.3.2 Plot: gg_en &lt;- ggplot(dt_china, aes(x = long, y = lat, group = group, fill = total_confirm)) + labs(fill = &quot;Number of Confirm&quot;)+ geom_polygon()+ scale_fill_gradientn(colours = RColorBrewer::brewer.pal(8, &quot;GnBu&quot;), na.value = &quot;grey90&quot;, guide = guide_colourbar(barwidth = 25, barheight = 0.4, #put legend title on top of legend title.position = &quot;top&quot;)) + labs(fill = &quot;Number of Confirm&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + coord_map() + # map scale theme_void() + theme(legend.position = &quot;bottom&quot;, legend.title=element_text(size=12), # font size of the legend legend.text=element_text(size=10)) # add province name to the map gg_en+geom_text(data = centroids_en, aes(x = long, y = lat, label = name), inherit.aes = FALSE) This method is tedious as we need to deal with the shape data, and we could not see number of confirmed cases directly from the plot. So we introduce other two packages which are simpler and more interactive in the following parts. 7.4 Interactive Map with hchinamap The package hchinamap that allows interactive map plots and contains map with complete Chinese territory. hchinamap(name=data$province_CH, value=data$total_confirm, width=&quot;100%&quot;, height=&quot;400px&quot;, title=&quot;Covid map of China&quot;, region=&quot;China&quot;, minColor = &quot;#f1eef6&quot;, maxColor = &quot;#980043&quot;, itermName = &quot;Total confirmed&quot;, hoverColor = &quot;#f6acf5&quot;, ) Here, the map shows total confirmed cases in each province in China. One of the shortage of this package is that we can only use color to represent numeric values (number of confirmed cases in this plot). So, in this case, it is hard to tell from the color the relative confirmed cases in each province because the vast majority of the cases are concentrated in Hubei province, and other provinces have only relatively minimal confirmed cases. We can see that the map showing dark color in only Hubei province and merely white in all other provinces. An advantage is that we can also plot maps for provinces using this package. Take Hubei province for example, from the web-scraped data set, we created a data frame that contains total confirmed cases in each city in Hubei province. idx = match(&quot;湖北&quot;, h$name) hubei = h$children hubeidata&lt;-hubei[[idx]] write.csv(file=&#39;Hubei_data.csv&#39;,hubeidata, fileEncoding = &#39;UTF-8&#39;) hchinamap(name = hubeidata$name, value = hubeidata$total$confirm, width = &quot;100%&quot;, height = &quot;400px&quot;, title = &quot;Covid Map of Hubei&quot;, region = &quot;Hubei&quot;, minColor = &quot;#f1eef6&quot;, maxColor = &quot;#980043&quot;, itermName = &quot;Total confirmed&quot;, hoverColor = &quot;#f6acf5&quot;) 7.5 Interactive Map with leafletCN The package leafletCN provides four color methods: numeric, bin, quantile and factor. Coloring by quantile allows us to see how many cases each province have relative to other provinces, which solved the problem we have with hchinamap. And another good thing is that we could customize the content displayed on the area when clicked, so we could display the exact number of confirmed cases! geojsonMap(dat = data, mapName = &quot;china&quot;, namevar = ~ province_CH, valuevar = ~ total_confirm, popup = paste0(data$province_CH,data$province_EN,&quot;:&quot;,data$total_confirm), palette = &quot;Reds&quot;, legendTitle = &quot;Quantile of confirmed number&quot;, colorMethod=&quot;quantile&quot;) 7.6 Conclusion Other data could also be plot on the maps with the packages we introduced above, like population and temperature. Based on the feature of different datasets, you can try all packages and chose the most suitable one! Reference: https://liuyanguu.github.io/post/2020/06/12/ggplot-us-state-and-china-province-heatmap/ "],["chinese-translation-of-candela-package.html", "Chapter 8 Chinese Translation of Candela Package 8.1 Candela 8.2 Candela 包使用 8.3 组件 8.4 API文件 8.5 开发人员文件", " Chapter 8 Chinese Translation of Candela Package Wenjie Zhu and Jin Qian library(candela) Source File：https://readthedocs.org/projects/candela/downloads/pdf/latest/ Github Documentation Link: https://candela.readthedocs.io/en/latest/index.html 8.1 Candela Candela是用于Kitware的Resonant平台的可互操作的Web可视化组件的开源套件, 致力于通过标准化API提供可扩展的丰富可视化效果，以用于现实世界的数据科学应用程序。 集成组件包括： LineUp组件：由哈佛大学视觉计算小组和Caleydo项目进行的LineUp动态排名。 UpSet组件：哈佛大学视觉计算小组和Caleydo项目的UpSet集可视化。 OnSet组件：由乔治亚理工学院信息接口小组提供的OnSet可视化设置。 华盛顿大学互动数据实验室的Vega可视化。示例组件：ScatterPlot。 通过Kitware的Resonant平台进行的GeoJS地理空间可视化。示例组件：GeoDots。 8.1.1 开始 8.1.1.1 快速开始 – JavaScript 在名为index.html的文本文件中输入以下内容： &lt;body&gt; &lt;div id=&quot;vis&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var data = [ {x: 1, y: 3}, {x: 2, y: 4}, {x: 2, y: 3}, {x: 0, y: 1} ]; var el = document.getElementById(&#39;vis&#39;); var vis = new candela.components.ScatterPlot(el, { data: data, x: &#39;x&#39;, y: &#39;y&#39; }); vis.render(); &lt;/script&gt; &lt;/body&gt; 在浏览器中打开index.html以显示结果可视化。 8.1.1.2 快速开始 – Python 请确保您已安装Python 2.7和pip（在Linux和OS X系统上，本地软件包管理器应该足够了；对于Windows，请 参见此处）。 打开一个shell程序（例如OS X上的终端; Linux上的Bash或Windows上的命令提示符），然后使用以下命令来安装Candela软件包和Requests库，以从网络上获取示例数据： pip install pycandela requests 在UNIX系统上，您可能需要在root或用sudo执行此操作 发出以下命令以在浏览器中启动Jupyter Notebook服务器： jupyter-notebook Create a notebook from the New menu and enter the following in a cell, followed by Shift-Enter to execute the cell and display the visualization: 从“新建”菜单创建一个笔记本，然后在单元格中输入以下内容，然后按Shift-Enter键执行该单元格并显示可视化效果： import requests data = requests.get( &#39;https://raw.githubusercontent.com/vega/vega-datasets/gh-pages/data/iris.json&#39; ).json() import pycandela pycandela.components.ScatterPlot( data=data, color=&#39;species&#39;, x=&#39;sepalLength&#39;, y=&#39;sepalWidth&#39;) 8.1.1.3 快速开始 – R 下载并安装RStudio。 运行以下指令以安装Candela： install.packages(&#39;devtools&#39;) devtools::install_github(&#39;Kitware/candela&#39;, subdir=&#39;R/candela&#39;) 使用以下指令以显示mtcars数据集的散点图： library(candela) candela(&#39;ScatterPlot&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 8.2 Candela 包使用 8.2.1 安装 有两种方式可安装Candela。从标准组件仓库中下载（例如npm）或者从Python包索引（PyPI）中下载。从组件仓库中下载的方式比较简单，但仅限于能够下载公共发布版本；从源头下载稍显复杂，但能让你下载并运行最新开发版本。 8.2.1.1 从组件管理系统中安装 8.2.1.1.1 JavaScript 要安装Candela Javascript代码库至当前文件夹，执行以下代码： npm install candela 要安装Candela JavaScript代码库作为你网页应用的dependency, 并且将其加入你的package.json文件中, 执行以下代码: npm install --save candela 独立的JavaScript Candela包可以在node_modules/candela/dist/candela[.min].js中找到。 使用Webpack安装 如果您的项目使用Webpack构建过程，则可以使用Candela的捆绑式Webpack帮助程序功能轻松地将Candela包括在项目中，而不必使用完整大小的捆绑文件。概念是根据项目的需要直接包含Candela源文件，依靠Webpack帮助程序来安排要使用的正确加载程序和其他配置选项。例如，如果没有Webpack，您的源文件可能包含如下行： var candela = require(&#39;candela/dist/candela.min.js&#39;); var ScatterPlot = candela.components.ScatterPlot; 这将导致您的应用程序在运行时加载整个Candela捆绑包，如果您只想使用ScaterPlot组件，则可能不是最佳选择。相反，使用Webpack，可以按以下方式强制转换此代码： var ScatterPlot = require(&#39;candela/components/ScatterPlot&#39;); 为了确保您的构建过程为此文件使用了正确的加载程序，您应确保在项目的Webpack配置中使用Candela webpack帮助程序功能： var candelaWebpack = require(&#39;candela/webpack&#39;); module.exports = candelaWebpack({ // 这里是你原本的webpack设置 }); 这种方法使您的代码更简洁，更有意义，同时避免了不必要的大型应用程序包。 8.2.1.1.2 Python 可以在Python Package Index中找到适用于Candela的Python绑定的最新发行版。安装Candela的最简单方法是通过Python的软件包管理器Pip: 1. 安装依赖软件 安装以下软件: Python 2.7 Pip 在Linux和OS X计算机上，本地软件包管理器应足以安装它们。在Windows上，请查阅本指南以获取有关Python和Pip的建议。 2. 安装Candela Python软件包 在shell中使用这行指令来安装Candela包以及依赖项： pip install pycandela 您可能需要以管理员账户身份运行此命令，或使用使用sudo或类似方式。 8.2.1.2 从源头进行构建安装 在进行源头安装前，您需要使用以下Git指令克隆Candela的代码仓库: git clone git://github.com/Kitware/candela.git 该指令会创建一个名为candela的目录。里面包含了Candela的源代码。使用cd指令进入目录： cd candela 8.2.1.2.1 JavaScript Candela在GitHub上进行开发。如果您希望贡献代码或获取到最新开发版本，则可以按照以下步骤从GitHub下载，构建和安装： 1.下载依赖软件 要从源代码构建Candela，您将需要安装以下软件： Git Node.js npm cairo (在macOS操作系统上使用brew install cairo) 2.安装节点依赖项 使用以下指令以通过节点软件包管理器（NPM）安装必要的节点依赖项： npm install 需要的软件包将会被安装至名为node_modules的目录中。 3.开始构建过程 使用以下指令开始开始构建过程： npm run build 输出将会在build/candela/candela.js中创建一个构建完成的Candela软件包。 观察输出是否有任何错误。大多数情况下，指令运行错误会终止整个构建过程，并打印出具体错误信息。如果你需要任何解读错误信息的帮助，请在GitHub issues或者Gitter chat里给我们留言。 4.查看示例 Candela包含了许多测试需要的示例。它们也有助于学习Candela提供的多种可视化效果。要构建示例，请执行以下代码： npm run build:examples 查看示例，执行以下代码： npm run examples 5.运行测试套件 Candela配有一系列测试。要运行测试套件，你需要调用测试任务如下： npm run test:all 以上代码会执行单元以及图像测试。每个测试套件可单独用以下代码运行： npm run test:unit 以及： npm run test:image 以上每行指令都会在命令行生成摘要报告。 6. 建立文件 Candela使用ReadTheDocs主机上托管的Sphinx 文档。要在本地构建文档，请首先安装所需的Python依赖项： pip install -r requirements-dev.txt 当安装完成后，运行以下指令： npm run docs 文档将托管在 http://localhost:3000/ 主机上。 8.2.1.2.2 Python 1. 安装软件依赖项 要从Python使用Candela，您将需要Python 2.7和pip。 2.在本地安装库 pip install -e . 3.测试安装 使用以下指令以在浏览器中启动Jupyter Notebook服务器： jupyter-notebook 从“新建”菜单中创建一个笔记本，然后在单元格中输入以下内容，然后按Shift-Enter键执行该单元格并显示可视化效果： import requests data = requests.get( &#39;https://raw.githubusercontent.com/vega/vega-datasets/gh-pages/data/iris.json&#39; ).json() import pycandela pycandela.components.ScatterPlot( data=data, color=&#39;species&#39;, x=&#39;sepalLength&#39;, y=&#39;sepalWidth&#39;) 8.2.1.2.3 R-使用install_github或Git Checkout 此过程将直接从GitHub或从Candela的本地Git Checkout安装Candela。 1.安装R，并选择性安装RStudio 2.安装Candela软件包 要直接从GitHub安装： install.packages(&#39;devtools&#39;) devtools::install_github(&#39;Kitware/candela&#39;, subdir=&#39;R/candela&#39;, dependencies = TRUE) 要从Git checkout安装，请将工作目录设置为Git checkout，然后安装并检查安装。check()将运行测试并执行其他程序包检查。 install.packages(&#39;devtools&#39;) devtools::install(dependencies = TRUE) devtools::check() 3.测试安装 下面将创建mtcars数据集的散点图并将其保存到out.html： w &lt;- candela(&#39;ScatterPlot&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) htmlwidgets::saveWidget(w, &#39;out.html&#39;) 在RStudio中，当您引用可视化而不将其分配给变量时，可视化将出现在您的应用程序中： w 注意： saveWidget在RStudio外部运行时，需要安装Pandoc。请参阅安装说明进行安装。 8.2.2 版本控制 Candela 使用语义法版本命名法来命名版本号。这意味着每个发行版的版本号都可以确定该发行版中存在的功能级别和向后兼容性。 Candela的版本号有两种形式: x.y 和 x.y.z。x为主版本号, y为次版本号, z为补丁版本号。 遵循语义版本控制方法，主要版本代表了整个软件的稳定API。如果主版本号增加，则意味着可以向后兼容。也就是说，适用于1.3版的设置将适用于1.4、1.5和1.10版，但不应期望与2.0版一起使用。 次版本号代表了在前版中加入了新功能。所以1.1版将包含1.0版中未提供的某些功能，且可以确保向后兼容。 当对软件进行错误修复或其他更正时，补丁版本号将递增。 主版本号0比较特殊：本质上，在0.y系列中不保证兼容性。API和行为的稳定性从1.0版开始。 除了标准的语义版本控制做法外，Candela还在Git存储库中将当前版本号标记为“ dev”，从而为从源代码构建的Candela软件包产生了诸如“ 1.1dev”的版本号。发行协议会在将包上传到Python包索引之前，从版本号中删除该标签。 8.3 组件 8.3.1 条形图 (BarChart) 条形图。 x变量应为每个条形包含不同的值，而y变量将对应于每个条形的高度。颜色变量可用于为每个条着色。在单个x值有多个记录的情况下，可以使用合计将值组合成单个条。 该组件可以在candela/plugins/vega插件中找到。 8.3.1.1 示例 JavaScript &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d }); } var vis = new candela.components.BarChart(el, { data: data, x: &#39;a&#39;, y: &#39;b&#39; }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: d} for d in range(10)] pycandela.components.BarChart(data=data, x=&#39;a&#39;, y=&#39;b&#39;) R library(candela) candela(&#39;BarChart&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 8.3.1.2 可选参数 data (Table) 数据表。 x (String) x轴（条形位置）变量。 必须包含数字类数据。 请参见坐标轴刻度。 xType (String) x变量的数据类型。 默认值为’nominal’。 y (String) y轴（条形高度）变量。 必须包含数字类数据。 请参见坐标轴刻度。 yType (String) y变量的数据类型。 默认值为’quantitative’。 color (String) 用于为条形着色的变量。 colorType (String) 颜色变量的数据类型。 默认值为’nominal’。 aggregate (String) 当多个记录中的x值相同时，y值的合计模式。 默认值为’sum’。 width (Number) 图表的宽度（以像素为单位）。 请参阅调整大小。 height (Number) 图表的高度（以像素为单位）。 请参阅调整大小。 renderer (String) 是否以’svg’或’canvas’模式渲染（默认为’画布’）。 8.3.2 箱线图 (BoxPlot) 箱线图。可视化采用一组测量数据（变量），并为每个测量生成箱线图。可选的group变量会将数据划分为具有匹配数值的小组，并为每个组创建一个或一组箱形图。 该组件可以在candela/plugins/vega插件中找到。 8.3.2.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d/2 + 7 }); } var vis = new candela.components.BoxPlot(el, { data: data, fields: [&#39;a&#39;, &#39;b&#39;] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python data = [{&#39;a&#39;: d, &#39;b&#39;: d/2 + 7} for d in range(10)] pycandela.components.BoxPlot(data=data, fields=[&#39;a&#39;, &#39;b&#39;]) R library(candela) candela(&#39;BoxPlot&#39;, data=mtcars, fields=c(&#39;mpg&#39;, &#39;wt&#39;, &#39;disp&#39;)) 8.3.2.2 可选参数 data (Table) 数据表。 fields (Array of String) 用作于测量的变量。 可视化将为每个变量生成一个箱线图。必须包含数字或时间数据。请参见坐标轴刻度。 坐标轴类型将由数组中第一个变量的推断值选择。 x (String) group by 所使用的可选参数。 默认情况下，所有记录都放在一个组中。 请参见轴刻度。 x轴（条形位置）变量。 必须包含数字类数据。 请参见坐标轴刻度。 xType (String) x变量的数据类型。 默认值为’nominal’。 color (String) 用于为箱形图着色的变量。 colorType (String) 颜色变量的数据类型。 默认值为’nominal’。 width (Number) 图表的宽度（以像素为单位）。 请参阅调整大小。 height (Number) 图表的高度（以像素为单位）。 请参阅调整大小。 renderer (String) 是否以’svg’或’canvas’模式渲染（默认为’画布’）。 8.3.3 甘特图 (GanttChart) 甘特图。 数据表必须包含两个数字变量，start和end，用于指定水平条的开始和结束。 label变量可以指定每个项目的名称。 该组件可以在candela/plugins/vega插件中找到。 8.3.3.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = [ {name: &#39;Do this&#39;, level: 1, start: 0, end: 5}, {name: &#39;This part 1&#39;, level: 2, start: 0, end: 3}, {name: &#39;This part 2&#39;, level: 2, start: 3, end: 5}, {name: &#39;Then that&#39;, level: 1, start: 5, end: 15}, {name: &#39;That part 1&#39;, level: 2, start: 5, end: 10}, {name: &#39;That part 2&#39;, level: 2, start: 10, end: 15} ]; var vis = new candela.components.GanttChart(el, { data: data, label: &#39;name&#39;, start: &#39;start&#39;, end: &#39;end&#39;, level: &#39;level&#39;, width: 700, height: 200 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ dict(name=&#39;Do this&#39;, level=1, start=0, end=5), dict(name=&#39;This part 1&#39;, level=2, start=0, end=3), dict(name=&#39;This part 2&#39;, level=2, start=3, end=5), dict(name=&#39;Then that&#39;, level=1, start=5, end=15), dict(name=&#39;That part 1&#39;, level=2, start=5, end=10), dict(name=&#39;That part 2&#39;, level=2, start=10, end=15) ]; pycandela.components.GanttChart( data=data, label=&#39;name&#39;, start=&#39;start&#39;, end=&#39;end&#39;, level=&#39;level&#39;, width=700, height=200 ) R library(candela) data &lt;- list( list(name=&#39;Do this&#39;, level=1, start=0, end=5), list(name=&#39;This part 1&#39;, level=2, start=0, end=3), list(name=&#39;This part 2&#39;, level=2, start=3, end=5), list(name=&#39;Then that&#39;, level=1, start=5, end=15), list(name=&#39;That part 1&#39;, level=2, start=5, end=10), list(name=&#39;That part 2&#39;, level=2, start=10, end=15)) candela(&#39;GanttChart&#39;, data=data, label=&#39;name&#39;, start=&#39;start&#39;, end=&#39;end&#39;, level=&#39;level&#39;, width=700, height=200) 8.3.3.2 可选参数 data (Table) 数据表。 label (String) 用于标记每个任务的字段。 start (String) 代表每个任务结束开始的变量。 必须为数字。 end (String) 代表每个任务结束刻度的变量。 必须为数字。 level (String) 用作分层项目级别的字符串。 当前支持两个不同的值，遇到的第一个值将是级别1，该级别将展现的更为突出，而第二个值将是级别2。 type (String) 开始和结束变量的数据类型。 默认值为’quantitative’。 tickCount (String) 建议沿x轴放置的刻度线数量。 axisTitle (String) x轴的标题。 width (Number) 图表的宽度（以像素为单位）。 请参阅调整大小。 height (Number) 图表的高度（以像素为单位）。 请参阅调整大小。 renderer (String) 是否以’svg’或’canvas’模式渲染（默认为’画布’）。 8.3.4 地理空间图 (Geo) 使用GeoJS的地理空间图。 该组件可以在candela/plugins/geojs插件中找到。 8.3.4.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.style.width = &#39;500px&#39;; el.style.height = &#39;500px&#39;; document.body.appendChild(el); var data = [ {lat: 41.702, lng: -87.644}, {lat: 41.617, lng: -87.693}, {lat: 41.715, lng: -87.712} ]; var vis = new candela.components.Geo(el, { map: { zoom: 10, center: { x: -87.6194, y: 41.867516 } }, layers: [ { type: &#39;osm&#39; }, { type: &#39;feature&#39;, features: [ { type: &#39;point&#39;, data: data, x: &#39;lng&#39;, y: &#39;lat&#39; } ] } ] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ dict(lat=41.702, lng=-87.644), dict(lat=41.617, lng=-87.693), dict(lat=41.715, lng=-87.712) ] pycandela.components.Geo( map=dict( zoom=10, center=dict(x=-87.6194, y=41.867516) ), layers=[ dict(type=&#39;osm&#39;), dict( type=&#39;feature&#39;, features=[ dict(type=&#39;point&#39;, data=data, x=&#39;lng&#39;, y=&#39;lat&#39;) ] ) ] ) R library(candela) data = list( list(lat=41.702, lng=-87.644), list(lat=41.617, lng=-87.693), list(lat=41.715, lng=-87.712)) candela(&#39;Geo&#39;, map=list( zoom=10, center=list(x=-87.6194, y=41.867516) ), layers=list( list(type=&#39;osm&#39;), list( type=&#39;feature&#39;, features=list( list(type=&#39;point&#39;, data=data, x=&#39;lng&#39;, y=&#39;lat&#39;) ) ) ) ) 8.3.4.2 可选参数 map (Object) 描述GeoJS地图选项的key-value对。 layers (Array of Layer) 地图的图层。 8.3.4.3 Layers详述 图层包含描述GeoJS图层选项的key-value对。 这些选项会传递给GeoJS，但type设置为’feature’的图层的’feature’选项除外。 在这种情况下，’feature’选项是一组Feature的详述。 8.3.4.4 Feature详述 每个feature都是具有以下属性的对象： name (String) feature的名字。 type (String) feature的类 （现支持：‘point’）。 data (Table) 数据表。 x (String) 用于feature的x轴参数。 y (String) 用于feature的y轴参数。 8.3.5 地理点图(GeoDots) 使用GeoJS的地理空间视图，其位置用点标记。 纬度（latitude）和经度 （longitude）变量包含数据中每个位置的经/纬度值。 该组件可以在candela/plugins/geojs插件中找到。 8.3.5.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.style.width = &#39;500px&#39;; el.style.height = &#39;500px&#39;; document.body.appendChild(el); var data = [ {lat: 41.702, lng: -87.644, a: 5}, {lat: 41.617, lng: -87.693, a: 15}, {lat: 41.715, lng: -87.712, a: 25} ]; var vis = new candela.components.GeoDots(el, { zoom: 10, center: { longitude: -87.6194, latitude: 41.867516 }, data: data, latitude: &#39;lat&#39;, longitude: &#39;lng&#39;, size: &#39;a&#39;, color: &#39;a&#39; }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ dict(lat=41.702, lng=-87.644, a=5), dict(lat=41.617, lng=-87.693, a=15), dict(lat=41.715, lng=-87.712, a=25) ] pycandela.components.GeoDots( zoom=10, center=dict(longitude=-87.6194, latitude=41.867516), data=data, latitude=&#39;lat&#39;, longitude=&#39;lng&#39;, size=&#39;a&#39;, color=&#39;a&#39; ) R library(candela) data = list( list(lat=41.702, lng=-87.644, a=5), list(lat=41.617, lng=-87.693, a=15), list(lat=41.715, lng=-87.712, a=25)) candela(&#39;GeoDots&#39;, zoom=10, center=list(longitude=-87.6194, latitude=41.867516), data=data, latitude=&#39;lat&#39;, longitude=&#39;lng&#39;, size=&#39;a&#39;, color=&#39;a&#39;) 8.3.5.2 可选参数 data (Table) 数据表。 longitude (String) 经度变量。 latitude (String) 纬度变量。 color (String) 用来为点着色的变量。 size (String) 用来确定点的大小的变量。 该字段必须包含数字值。 zoom (Integer) 初始缩放程度。 center (Object) 具有经度和纬度属性的对象，用于指定地图的初始中心。 tileUrl (String) 切片URL模板（请参见GeoJS OSM图层选项）。 设置为null可完全禁用OSM层。 8.3.6 图级操作 (GLO - Graph-Level Operations) 可视化框架。将数据看作图形的节点，使用定位和视觉命令将它们排列为不同的格式，以实现不同的可视化。 节点表包含一个对象列表，每个对象都有一个包含唯一标识符的id变量以及所需的其他数据属性。边缘表（edges table）包含源头和目标变量（各自指向引用节点表中的id值）、无向或有向的可选类变量、标识每个边缘的id参数、以及权重值（可选）。 width和height控制用于呈现可视化效果的画布的大小。 该组件可以在candela/plugins/glo插件中找到。 8.3.6.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.setAttribute(&#39;width&#39;, 700); el.setAttribute(&#39;width&#39;, 700); document.body.appendChild(el); var alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;; var vowels = &#39;aeiou&#39;.split(&#39;&#39;); var nodes = []; for (var i = 0; i &lt; 26; i++) { var letter = { id: i, label: alphabet[i], vowel: vowels.indexOf(alphabet[i]) &gt; 0 ? &#39;vowel&#39; : &#39;consonant&#39; }; for (var j = 0; j &lt; 26; j++) { letter[alphabet[j]] = Math.abs(j - i); } nodes.push(letter); } var edges = []; var counter = 0; for (var i = 0; i &lt; 26; i++) { for (var j = i + 1; j &lt; 26; j++) { if (nodes[i][alphabet[j]] &gt; 20) { edges.push({ source: i, target: j, type: &#39;Undirected&#39;, id: counter++, weight: 1 }); } } } var vis = new candela.components.Glo(el, { nodes: nodes, edges: edges, width: 700, height: 200 }); vis.render(); vis.distributeNodes(&#39;x&#39;); vis.colorNodesDiscrete(&#39;vowel&#39;); vis.curvedEdges(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ {&#39;id&#39;: 0, &#39;label&#39;: &#39;A&#39;, &#39;class&#39;: 0}, {&#39;id&#39;: 1, &#39;label&#39;: &#39;B&#39;, &#39;class&#39;: 1}, {&#39;id&#39;: 2, &#39;label&#39;: &#39;C&#39;, &#39;class&#39;: 1} ] edges = [ {&#39;id&#39;: 0, &#39;source&#39;: 0, &#39;target&#39;: 1}, {&#39;id&#39;: 1, &#39;source&#39;: 0, &#39;target&#39;: 2}, {&#39;id&#39;: 2, &#39;source&#39;: 2, &#39;target&#39;: 1} ] glo = pycandela.components.Glo(nodes=nodes, edges=edges) glo.render() glo.distributeNodes(&#39;x&#39;); glo.colorNodesDiscrete(&#39;class&#39;); glo.curvedEdges(); R library(candela) id = c(0, 1, 2) label = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) class = c(0, 1, 1) nodes = data.frame(id, label, class) source = c(0, 0, 2) target = c(1, 2, 1) edges = data.frame(id, source, target) glo = candela(&#39;SimilarityGraph&#39;, nodes=nodes, edges=edges) glo.render() glo.distributeNodes(&#39;x&#39;) glo.colorNodesDiscrete(&#39;class&#39;) glo.curvedEdges() 8.3.6.2 可选参数 nodes (Table) 节点表。 edges (Table) 边缘表。 width (number) 绘图区域宽度。 height (number) 绘图区域高度。 8.3.6.3 函数方程 colorNodesDiscrete(field) 参数： - field (string) – 要着色的变量 使用分类颜色图（color map）通过变量中的值为节点着色。 colorNodesContinuous(field) 参数： - field (string) – 要着色的变量 使用连续的颜色图（color map）通过变量中的值为节点着色。 colorNodesDefault() 将节点颜色恢复为默认状态（无颜色图）。 sizeNodes(field) 参数： - field (string) – 用于调整大小的变量 根据变量中的值调整节点的大小。 sizeNodesDefault() 将节点大小恢复为默认状态（固定大小）。 distributeNodes(axis[, attr]) 参数： - string (attr) – 分布节点的轴 -string -– 用于对节点进行分组的参数 沿轴均匀放置节点，该轴必须是“ x”，“ y”，“ rho”（径向轴）或“ theta”（角度轴）之一。如果指定了attr，则将根据此attr对节点进行分区和分组。 positionNodes(axis, value) 参数: - axis (string) – 分布节点的轴 - value (string|number) – 用于绘制位置数据的变量或常量 根据值中的数据沿轴定位节点（请参见distributionNodes()）。如果value是字符串，则表示节点表中的列；如果是数字，则所有节点都将被放置于该位置。 forceDirected() 将力导引算法（force-directed positioning）应用于节点。 showEdges() 展示所有节点之间的边。 hideEdges() 隐藏所有节点之间的边。 fadeEdges() 使用透明的灰色渲染边缘。 solidEdges() 使用黑色渲染边缘。 incidentEdges() 仅在鼠标指针悬停在节点上时，渲染入射在该节点上的边缘。 curvedEdges() 使用曲线渲染边缘。 straightEdges() 使用直线渲染边缘。 8.3.7 直方图 (Histogram) 直方图。参数bin指定要汇总的字段。默认情况下，数据表data中的每条记录占bin的总数的1。 通过指定一个汇总字段aggregate，将在每个bin里加总该字段。 该组件可以在candela/plugins/vega插件中找到。 8.3.7.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 1000; d += 1) { data.push({ a: Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random()) }); } var vis = new candela.components.Histogram(el, { data: data, x: &#39;a&#39;, width: 700, height: 400 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela from random import normalvariate as nv data = [{&#39;a&#39;: nv(0, 1)} for d in range(1000)] pycandela.components.Histogram(data=data, x=&#39;a&#39;, width=700, height=400) R library(candela) candela(&#39;Histogram&#39;, data=mtcars, x=&#39;mpg&#39;) 8.3.7.2 可选参数 data (Table) 数据表。 x (String) x轴字段，组合为直方图。 xType (String) x字段的数据类型。默认值是“名义变量”。 aggregate (String) 每个直方图bin中y值的聚合模式。默认值为“计数”，它不使用y值，但将统计bin中出现的记录数。 y (String) y轴字段，当没设置聚合为“计数”时，用于确定直方图条的高度。 yType (String) y字段的数据类型。默认值为“定量”。 color (String) 用于为条形着色的字段。 colorType (String) 颜色字段的数据类型。默认值为“名义变量”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 8.3.8 折线图 (LineChart) 折线图。该图表针对单个x字段绘制了y字段的线，可以选择使用系列字段series将其分成多条线。 该组件可以在candela/plugins/vega插件中找到。 8.3.8.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d }); } var vis = new candela.components.LineChart(el, { data: data, x: &#39;a&#39;, y: &#39;b&#39;, width: 700, height: 400 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: d} for d in range(10)] pycandela.components.LineChart( data=data, x=&#39;a&#39;, y=&#39;b&#39;, width=700, height=400) R library(candela) candela(&#39;LineChart&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 8.3.8.2 可选参数 data (Table) 数据表。 x (String) x轴字段，组合为直方图。 xType (String) x字段的数据类型。默认值是“名义变量”。 y (String) y轴字段，当没设置聚合为“计数”时，用于确定直方图条的高度。 yType (String) y字段的数据类型。默认值为“定量”。 series (String) 用于将数据分隔成多行的可选字段。 seriesType (String) 序列字段的数据类型。默认值为“名义变量”。 colorSeries (Boolean) 是否为不同序列上色并显示图例。默认为“是”。 showPoints (Boolean) 是否在直线上添加点。默认值为“否”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 8.3.9 排序图(Lineup) LineUp用于排名可视化。 可以在candela/plugins/lineup插件中找到该组件。 8.3.9.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: 10 - d, name: d }); } var vis = new candela.components.LineUp(el, { data: data, fields: [&#39;a&#39;, &#39;b&#39;] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: 10 - d, &#39;name&#39;: d} for d in range(10)] pycandela.components.LineUp(data=data, fields=[&#39;a&#39;, &#39;b&#39;]) R library(candela) candela(&#39;LineUp&#39;, data=mtcars, fields=c(&#39;_row&#39;, &#39;mpg&#39;, &#39;wt&#39;, &#39;disp&#39;)) 8.3.9.2 可选参数 data (Table) 数据表。 fields (Array of String) 将在LineUp视图上显示的字段列表。该列表确定字段的顺序。如果未提供，则显示数据中的所有字段。 stacked (Boolean) 是否将分组的度量显示为堆叠的条形（默认为“否”）。 histograms (Boolean) 是否在每个度量的标题中显示直方图（默认为“是”）。 animation (Boolean) 是否在评分标准更改时设置过渡动画（默认为“是”）。 8.3.10 OnSet组件 (OnSet) 8.3.10.1 示例 OnSet集合可视化. OnSet将二进制列（即每行中文本为“ 0”或“ 1”，“true”或“false”，“yes”或“no”的列）解释为集合。 sets选项中的任何字段都将以这种方式解释。 由于大多数数据不是按二进制列排列的，因此可视化还通过field选项支持任意类别的字段。 此列表中指定的每个字段首先将被预处理为一个集合集，每个集合值对应的名称为&lt;fieldName&gt;&lt;value&gt; 例如，假设数据表为： [ {&quot;id&quot;: &quot;n1&quot;, &quot;f1&quot;: 1, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n2&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n3&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;y&quot;} ] 可以使用以下选项创建OnSet可视化： new OnSet({ data: data, id: &#39;id&#39;, sets: [&#39;f1&#39;], fields: [&#39;f2&#39;] }); 如下所示，这会将f2字段预处理为f2 x和f2 y，并使它们可用于OnSet： f1: n1 f2 x: n1, n2 f2 y: n3 如果rowSets选项设置为true，则集合将转变为： n1: f1, f2 x n2: f2 x n3: f2 y 该组件可以在candela/plugins/onset插件中找到。 8.3.10.2 可选参数 data (Table) 数据表。 id (String) 包含每个记录的唯一ID的字段。 fields (Array of String) 分类字段的列表，这些字段将每个字段中每个不同值的转换为0/1组集合，并填充在OnSet视图中。 rowSets (Boolean) 如果为false，则将列视为集合；如果为true，则将行视为集合。默认为“否”。 8.3.11 散点图 (ScatterPlot) 散点图。 该可视化将在指定的x和y位置绘制值。其他字段可以确定绘制点的颜色color，大小size和形状shape。 该组件可以在candela/plugins/vega插件中找到。 #### 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d }); } var vis = new candela.components.ScatterPlot(el, { data: data, x: &#39;a&#39;, y: &#39;b&#39;, width: 700, height: 400 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: d} for d in range(10)] pycandela.components.ScatterPlot( data=data, x=&#39;a&#39;, y=&#39;b&#39;, width=700, height=400) R library(candela) candela(&#39;ScatterPlot&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 8.3.11.1 可选参数 data (Table) 数据表。 x (String) x轴字段。 xType (String) x字段的数据类型。默认值是“名义变量”。 y (String) y轴字段。 yType (String) y字段的数据类型。默认值为“定量”。 color (String) 该字段用于给点上色。 colorType (String) color颜色字段的数据类型。默认为“名义变量”。 size (String) 该字段用于改变点的大小。 sizeType (String) size大小字段的数据类型。默认值为“定量”。 shape (String) 该字段用于改变点的形状。 shapeType (String) shape形状字段的数据类型。默认值为“名义变量”。 filled (String) 是填充点还是仅绘制轮廓。默认值为“是”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 8.3.12 散点图矩阵 (ScatterPlotMatrix) 散点图矩阵。该可视化将为每对指定字段fields绘制散点图。其他字段可以确定点的大小size，颜色color和形状shape。 该组件可以在candela/plugins/vega插件中找到。 8.3.12.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: 10 - d, name: d }); } var vis = new candela.components.ScatterPlotMatrix(el, { data: data, fields: [&#39;a&#39;, &#39;b&#39;] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: 10 - d, &#39;name&#39;: d} for d in range(10)] pycandela.components.ScatterPlotMatrix(data=data, fields=[&#39;a&#39;, &#39;b&#39;]) R library(candela) candela(&#39;ScatterPlotMatrix&#39;, data=mtcars, fields=c(&#39;mpg&#39;, &#39;wt&#39;, &#39;disp&#39;)) 8.3.12.2 可选参数 data (Table) 数据表。 fields (Array of String) 该字段在散点图矩阵中用作轴。指定N个字段将生成N x N的散点图矩阵。 color (String) 该字段用于给点上色。 colorType (String) 颜色字段的数据类型。默认为“名义变量”。 size (String) 该字段用于改变点的大小。 sizeType (String) size大小字段的数据类型。默认值为“定量”。 shape (String) 该字段用于改变点的形状。 shapeType (String) shape形状字段的数据类型。默认值为“名义变量”。 filled (String) 是填充点还是仅绘制轮廓。默认值为“是”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 8.3.13 词树 (SentenTree) 词树：句子可视化。 给定一个有关某个主题的文本样本表，SentenTree尝试抽象出它们之间的共同表达，将它们可视化为“句子树”。 数据表data包含一系列对象，每个对象都有一个id字段，该字段包含每行的唯一标识符，一个文本text字段，包含文本样本，一个计数count字段，表示该样本的强度或在语料库中发生的次数等。 可以在candela/plugins/sententree插件中找到此组件。 #### 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.setAttribute(&#39;width&#39;, 1200); el.setAttribute(&#39;width&#39;, 700); document.body.appendChild(el); var data = [ {id: 0, count: 3787, text: &#39;brazil\\&#39;s marcelo scores the first goal of the world cup ... against brazil.&#39;}, {id: 1, count: 2878, text: &#39;at least brazil have scored the first goal of the world cup&#39;}, {id: 2, count: 1702, text: &#39;first game of the world cup tonight! can\\&#39;t wait!&#39;}, {id: 3, count: 1689, text: &#39;the first goal of the world cup is an own goal! marcelo accidentally knocks it into his own net past julio cesar! croatia leads 1-0.&#39;}, {id: 4, count: 1582, text: &#39;goal: brazil 0-1 croatia marcelo scores an own goal in the 11th minute&#39;}, {id: 5, count: 1525, text: &#39;just like we predicted, a brazilian scored the first goal in the world cup&#39;}, {id: 6, count: 1405, text: &#39;whoever bet that the first goal of the world cup was going to be an own goal just made a lot of money.&#39;}, {id: 7, count: 1016, text: &#39;736 players 64 matches 32 teams 12 stadiums 4 years of waiting 1 winning country the 2014 world cup has started .&#39;}, {id: 9, count: 996, text: &#39;watching the world cup tonight! with the tour fam&#39;}, {id: 10, count: 960, text: &#39;the first goal of the world cup was almost as bad as the opening ceremony.&#39;}, {id: 11, count: 935, text: &#39;live from the 2014 fifa world cup in brazil, the unveiling of the happiness flag.&#39;}, {id: 13, count: 915, text: &#39;world cup starts today!!!!!! amazing!!!&#39;}, {id: 14, count: 818, text: &#39;the first goal scored of the world cup 2014... was an own goal!&#39;}, {id: 15, count: 805, text: &#39;after 4 years, the wait is finally over.&#39;}, {id: 16, count: 803, text: &#39;that\\&#39;s not in the script! own goal from marcelo puts croatia up 0-1.&#39;}, {id: 17, count: 746, text: &#39;that moment when you score an own goal in the opening game of the world cup.&#39;}, {id: 18, count: 745, text: &#39;scoring on themselves in the world cup&#39;}, {id: 19, count: 719, text: &#39;world cup 2014 first goal is own-goal by marcelo&#39;} ]; var vis = new candela.components.SentenTree(el, { data: data, graphs: 3 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ {&#39;id&#39;: 0, &#39;count&#39;: 3787, &#39;text&#39;: &#39;brazil\\&#39;s marcelo scores the first goal of the world cup ... against brazil.&#39;}, {&#39;id&#39;: 1, &#39;count&#39;: 2878, &#39;text&#39;: &#39;at least brazil have scored the first goal of the world cup&#39;}, {&#39;id&#39;: 2, &#39;count&#39;: 1702, &#39;text&#39;: &#39;first game of the world cup tonight! can\\&#39;t wait!&#39;}, {&#39;id&#39;: 3, &#39;count&#39;: 1689, &#39;text&#39;: &#39;the first goal of the world cup is an own goal! marcelo accidentally knocks it into his own net past julio cesar! croatia leads 1-0.&#39;}, {&#39;id&#39;: 4, &#39;count&#39;: 1582, &#39;text&#39;: &#39;goal: brazil 0-1 croatia marcelo scores an own goal in the 11th minute&#39;}, {&#39;id&#39;: 5, &#39;count&#39;: 1525, &#39;text&#39;: &#39;just like we predicted, a brazilian scored the first goal in the world cup&#39;}, {&#39;id&#39;: 6, &#39;count&#39;: 1405, &#39;text&#39;: &#39;whoever bet that the first goal of the world cup was going to be an own goal just made a lot of money.&#39;}, {&#39;id&#39;: 7, &#39;count&#39;: 1016, &#39;text&#39;: &#39;736 players 64 matches 32 teams 12 stadiums 4 years of waiting 1 winning country the 2014 world cup has started .&#39;}, {&#39;id&#39;: 9, &#39;count&#39;: 996, &#39;text&#39;: &#39;watching the world cup tonight! with the tour fam&#39;}, {&#39;id&#39;: 10, &#39;count&#39;: 960, &#39;text&#39;: &#39;the first goal of the world cup was almost as bad as the opening ceremony.&#39;}, {&#39;id&#39;: 11, &#39;count&#39;: 935, &#39;text&#39;: &#39;live from the 2014 fifa world cup in brazil, the unveiling of the happiness flag.&#39;}, {&#39;id&#39;: 13, &#39;count&#39;: 915, &#39;text&#39;: &#39;world cup starts today!!!!!! amazing!!!&#39;}, {&#39;id&#39;: 14, &#39;count&#39;: 818, &#39;text&#39;: &#39;the first goal scored of the world cup 2014... was an own goal!&#39;}, {&#39;id&#39;: 15, &#39;count&#39;: 805, &#39;text&#39;: &#39;after 4 years, the wait is finally over.&#39;}, {&#39;id&#39;: 16, &#39;count&#39;: 803, &#39;text&#39;: &#39;that\\&#39;s not in the script! own goal from marcelo puts croatia up 0-1.&#39;}, {&#39;id&#39;: 17, &#39;count&#39;: 746, &#39;text&#39;: &#39;that moment when you score an own goal in the opening game of the world cup.&#39;}, {&#39;id&#39;: 18, &#39;count&#39;: 745, &#39;text&#39;: &#39;scoring on themselves in the world cup&#39;}, {&#39;id&#39;: 19, &#39;count&#39;: 719, &#39;text&#39;: &#39;world cup 2014 first goal is own-goal by marcelo&#39;} ] pycandela.components.SentenTree(data=data, id=&#39;id&#39;, count=&#39;count&#39;, text=&#39;text&#39;) R library(candela) id = c(0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19) count = c(3787, 2878, 1702, 1689, 1582, 1525, 1405, 1016, 996, 960, 935, 915, 818, 805, 803, 746, 745, 719) text = c(&#39;brazil\\&#39;s marcelo scores the first goal of the world cup ... against brazil.&#39;, &#39;at least brazil have scored the first goal of the world cup&#39;, &#39;first game of the world cup tonight! can\\&#39;t wait!&#39;, &#39;the first goal of the world cup is an own goal! marcelo accidentally knocks it into his own net past julio cesar! croatia leads 1-0.&#39;, &#39;goal: brazil 0-1 croatia marcelo scores an own goal in the 11th minute&#39;, &#39;just like we predicted, a brazilian scored the first goal in the world cup&#39;, &#39;whoever bet that the first goal of the world cup was going to be an own goal just made a lot of money.&#39;, &#39;736 players 64 matches 32 teams 12 stadiums 4 years of waiting 1 winning country the 2014 world cup has started .&#39;, &#39;watching the world cup tonight! with the tour fam&#39;, &#39;the first goal of the world cup was almost as bad as the opening ceremony.&#39;, &#39;live from the 2014 fifa world cup in brazil, the unveiling of the happiness flag.&#39;, &#39;world cup starts today!!!!!! amazing!!!&#39;, &#39;the first goal scored of the world cup 2014... was an own goal!&#39;, &#39;after 4 years, the wait is finally over.&#39;, &#39;that\\&#39;s not in the script! own goal from marcelo puts croatia up 0-1.&#39;, &#39;that moment when you score an own goal in the opening game of the world cup.&#39;, &#39;scoring on themselves in the world cup&#39;, &#39;world cup 2014 first goal is own-goal by marcelo&#39;) data = data.frame(id, count, text) candela(&#39;SentenTree&#39;, data=data, id=&#39;id&#39;, color=&#39;class&#39;, threshold=0.4) 8.3.13.1 可选参数 data (Table) 数据表。 id（String） ID字段。可以包含任何数据类型，但是该值对于每个数据记录而言都是唯一的。 text（String） 文本样本字段。 count (Integer) 表示每个文本样本的数量或强度的字段。 8.3.14 相似图 (SimilarityGraph) 交互式相似图。给定一个对其他实体的连接强度进行编码的实体列表，此组件将创建一个以实体为节点的图形，并在连接强度超过某个阈值的节点之间出现链接。 数据表data包含一个对象列表，每个对象都有一个id字段，其中包含每个实体的唯一标识符。每个对象还应该有一个由其他实体的id命名的数字字段，其中包含到每个实体的链接强度。如果缺少任何实体的链接强度，则假定其为0。每个对象可以选择包含一个颜色字段color和一个大小size字段，该颜色字段包含标识其颜色的值，大小字段可以是每个半径的数字（以像素为单位）节点，也可以是标识数据中字段的字符串，该字段包含一个将映射到每个节点半径的数字。threshold是一个数值，指定要在图中显示的链接强度的最小值。linkDistance设置所需的链接长度（以像素为单位）。 这个组件可以在candela/plugins/similaritygraph插件中找到。 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.setAttribute(&#39;width&#39;, 700); el.setAttribute(&#39;width&#39;, 700); document.body.appendChild(el); var alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;; var vowels = &#39;aeiou&#39;.split(&#39;&#39;); var data = []; for (var i = 0; i &lt; 26; i++) { var letter = { id: alphabet[i], size: 10 + i, color: vowels.indexOf(alphabet[i]) &gt; 0 ? &#39;vowel&#39; : &#39;consonant&#39; }; for (var j = 0; j &lt; 26; j++) { letter[alphabet[j]] = Math.abs(j - i); } data.push(letter); } var vis = new candela.components.SimilarityGraph(el, { data: data, size: &#39;size&#39;, threshold: 20 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ {&#39;id&#39;: &#39;A&#39;, &#39;class&#39;: 0, &#39;A&#39;: 1.0, &#39;B&#39;: 0.5, &#39;C&#39;: 0.3}, {&#39;id&#39;: &#39;B&#39;, &#39;class&#39;: 1, &#39;A&#39;: 0.5, &#39;B&#39;: 1.0, &#39;C&#39;: 0.2}, {&#39;id&#39;: &#39;C&#39;, &#39;class&#39;: 1, &#39;A&#39;: 0.3, &#39;B&#39;: 0.2, &#39;C&#39;: 1.0} ] pycandela.components.SimilarityGraph(data=data, id=&#39;id&#39;, color=&#39;class&#39;, threshold=0.4) R library(candela) id = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) class = c(0, 1, 1) A = c(1.0, 0.5, 0.3) B = c(0.5, 1.0, 0.2) C = c(0.3, 0.2, 1.0) data = data.frame(id, class, A, B, C) candela(&#39;SimilarityGraph&#39;, data=data, id=&#39;id&#39;, color=&#39;class&#39;, threshold=0.4) 8.3.14.1 可选参数 data (Table) 数据表。 id（String） ID字段。可以包含任何数据类型，但是该值对于每个数据记录而言都是唯一的。 color (String) 用于为节点着色的字段。请参阅API文件的色阶。 size (String or Number) 如果是字符串，则该字段用于提供每个节点的半径；如果为数字，则为所有节点使用的半径。 threshold (Number) 高于该强度临界值的链接将出现在图形中。 linkDistance (Number) 每个链接的期望长度（以像素为单位）。 8.3.15 树状图(Tree Heatmap) 带有附加到行和列的可选层次结构的热图。 该组件可以在candela / plugins / treeheatmap插件中找到。 #### 示例 以下示例假定您已下载 示例数据。 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;vis&quot; style=&quot;width:600px;height:600px&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; &gt; var el = document.getElementById(&#39;vis&#39;); d3.json(&#39;heatmap.json&#39;, function (error, data) { var vis = new candela.components.TreeHeatmap(el, { data: data, scale: &#39;column&#39; }); vis.render(); }); &lt;/script&gt; &lt;/body&gt; Python import pycandela import json data = json.load(open(&#39;heatmap.json&#39;)) pycandela.components.TreeHeatmap(data=data, scale=&#39;column&#39;) R library(candela) library(jsonlite) data &lt;- fromJSON( &#39;https://candela.readthedocs.io/en/latest/_static/heatmap.json&#39;) candela(&#39;TreeHeatmap&#39;, data=data, scale=&#39;column&#39;) 8.3.15.1 可选参数 data (Table) 数据表。 idColumn (String) 具有唯一标识符的列。如果未设置，则可视化将使用名称为空的列，或者(如果存在)使用名为“ _”或“ _id”的列。 scale (String) 指定是使用全局比例尺（“ global”）为数据值着色，单独缩放每一行或每一列（“ row”或“ column”）还是使用适合于相关矩阵（“correlation”）的-1到1色标。如果未指定此参数，则视图使用全局比例。 clusterRows (Boolean) 如果设置为true，则按层次集群链接对行进行排序。此选项需要专门定义的列，名称为“cluster”，“ child1”，“ _ child2”，“ _distance”和“_size”来定义行的聚类。有关如何创建适当的层次结构列的示例，请参见 pysciencedock中的 热图分析。 clusterColumns (Boolean) 如果设置为true，则按层次集群链接对列进行排序。此选项需要专门定义的名为“_cluster”，“child1”，“ child2”，“_distance”和“ _size”的行来定义列的聚类。有关如何创建适当的层次结构行的示例，请参见 pysciencedock中的 热图分析。 threshold (Number) 根据阈值模式设定阈值。 thresholdMode (String) 如果设置，则使用阈值仅显示表格中的某些单元格。有效值为“none”（无阈值），“greater than”（显示大于阈值的值），“less than”（显示小于阈值的值）或“absolute value greater than”（仅显示绝对值大于阈值的值）。如果设置为“ none”以外的任何值，则还必须设置阈值参数。 removeEmpty (Boolean) 如果为true，则全部删除由阈值过滤掉的行和列。如果设置此标志，将不使用按行和列进行聚类。 8.3.16 集合可视化 (UpSet) 集合可视化。 UpSet将二进制列（即每行为文字“0”或“1”，“true”或“false”，“yes”或“no”的列）解释为集合。 sets选项中的任何字段都将以这种方式解释。 由于大多数数据未按照二进制列形式排列，因此可视化还通过“fields”选项支持任意类别的字段。 此列表中指定的每个字段将首先被预处理为0/1列的集合，然后将其传递给UpSet。 例如，假设数据表为： [ {&quot;id&quot;: &quot;n1&quot;, &quot;f1&quot;: 1, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n2&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n3&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;y&quot;} ] 您可以使用以下选项创建UpSet可视化文件： new UpSet({ data: data, id: &#39;id&#39;, sets: [&#39;f1&#39;], fields: [&#39;f2&#39;] }); 如下所示，这会将f2字段预处理为f2 x和f2 y集合，并使它们可用于UpSet： [ {&quot;id&quot;: &quot;n1&quot;, &quot;f1&quot;: 1, &quot;f2 x&quot;: 1, &quot;f2 y&quot;: 0}, {&quot;id&quot;: &quot;n2&quot;, &quot;f1&quot;: 0, &quot;f2 x&quot;: 1, &quot;f2 y&quot;: 0}, {&quot;id&quot;: &quot;n3&quot;, &quot;f1&quot;: 0, &quot;f2 x&quot;: 0, &quot;f2 y&quot;: 1} ] 该组件可以在插件candela/plugins/upset包中找到。 8.3.16.1 可选参数 data (Table) 数据表。 id（String） 包含每个记录的唯一标识符的字段。 fields (Array of String) 将在UpSet视图中显示的字段列表。 每个字段中的值在传递给UpSet之前都将转换为设置的0/1字段。 sets (Array of String) 将在UpSet视图中显示的字段列表。 假定每个字段已经是0/1集字段。 metadata (Array of String) 向下钻取单个记录时将显示为元数据的字段列表。数字数据还将显示在每组右侧的摘要框图中。 8.4 API文件 8.4.1 Candela JavaScript API candela.components – Candela内置组件。 Sizing Field matchings Data types Visualization components –Candela组件基类。 candela.mixins – Candela内置组件Mixin。 Utilities – Candela实用功能。 8.4.1.1 组件 Candela随附了几个可立即使用的可视化组件。为了使这些组件更容易地包含在您的项目中，它们被分为几个内置插件。每个插件通过其index.js文件导出其内容： import * as candelaVega from &#39;candela/plugins/vega&#39;; let vis = new candelaVega.BarChart(...); 并可以通过其load.js文件将其内容加载到candela.components对象，如下所示： import candela from &#39;candela&#39;; import &#39;candela/plugins/vega/load.js&#39;; let vis = new candela.components.BarChart(...); 您也可以直接导入组件： import BarChart from &#39;candela/plugins/vega/BarChart&#39;; let vis = new BarChart(...); 最后，您还可以导入candela捆绑包，该捆绑包的构建是为了包含每个预装到candela.components中的组件： import candela from &#39;candela/dist/candela&#39;; let vis = new candela.components.BarChart(...); 但是candela捆绑包非常大。使用其他方法之一构建应用程序将产生一个更小，更易于管理的大小的捆绑包。 当前的插件列表是： candela/plugins/vega – 基于Vega的图表，包括基本图表类型，例如条形图，散点图和直方图。 candela/plugins/geojs – 基于GeoJS的组件用于地理空间数据可视化。 candela/plugins/glo – 基于GLO的组件-“图形级操作”。 candela/plugins/lineup – 基于LineUp的组件，用于可视化排序。 candela/plugins/onset – 基于OnSet的组件，用于可视化子集关系。 candela/plugins/sententree - 基于SentenTree的组件，用于可视化文本语料库的语法结构。 candela/plugins/similaritygraph – 一种专用的交互式图形可视化组件，用于调查数据表中节点之间的相似度。 candela/plugins/trackerdash – 基于TrackerDash算法指标跟踪仪表板的组件。 candela/plugins/treeheatmap – 一个结合了层次聚类的热图。 candela/plugins/upset – 基于UpSet的组件，也用于可视化子集关系。 有关每个组件的更多详细信息（包括如何将这些捆绑包导入到项目中），请参阅组件文档的完整列表。 8.4.1.2 尺寸调整 组件通常具有’width’和’height’选项，该选项以像素为单位指定组件的宽度和高度。 8.4.1.3 变量 8.4.1.3.1 坐标轴刻度 几个组件具有与可视化轴相关的选项。这些通常称为x和y，但也可能具有更描述性的名称。该组件通常会自动检测要映射到轴的字段中的值的类型，并会创建适当的轴类型，例如字符串字段的均等值和数字字段和日期字段的连续范围轴。显示连续范围的轴的可视化通常允许通过在可视化区域中拖动和滚动来平移和缩放轴。 The component will often automatically detect the type of values in the field being mapped to an axis and will create an appropriate axis type, such as evenly-spaced values for string fields and a continuous-ranged axis for numeric and date fields. 8.4.1.3.2 色标 许多Candela组件包含一个color选项，该选项将通过指定的变量为可视元素着色。在可能的情况下，颜色将检测列的数据类型并使用适当的色标。对于包含字符串/文本值的字段，可视化将为每个唯一数值使用具有不同颜色的色标。对于包含数字或日期值的变量，可视化将使用从低到高的平滑颜色渐变。 8.4.1.4 资料类型 8.4.1.4.1 表格 Candela表是以下形式的记录的数组： [ { &quot;a&quot;: 1, &quot;b&quot;: &quot;Mark&quot;, &quot;c&quot;: &quot;Jun 1, 2010&quot; }, { &quot;a&quot;: 2, &quot;b&quot;: &quot;Andy&quot;, &quot;c&quot;: &quot;Feb 6, 2010&quot; }, { &quot;a&quot;: 3, &quot;b&quot;: &quot;Joe&quot;, &quot;c&quot;: &quot;Nov 27, 2010&quot; } ] 8.4.1.4.2 可视化组件 VisComponent是Candela可视化组件的基类。此类是故意最小的，因为所有Candela组件只有几个共同的特征： Candela组件可在网络上运行，因此构造函数为new VisComponent(el)，其中el（通常情况下）是DOM元素。 VisComponent构造函数将el附加到对象上，因此您始终可以使用this.el对其进行引用。 Candela组件都会执行某种类型的可视化，因此它们具有各自的生成（render）函数。基类生成函数只会抛出异常。 有时您需要在运行时更改可视化的某个方面，例如颜色图、哪些数据列正在背可视化、甚至是数据本身。为了支持此类更改，Candela组件提供了一种更新方法。基类更新返回一个promise对象，该对象将交付组件本身。 当可视化组件的生命周期即将结束时，可能需要对其进行清理，这可以通过组件的destroy函数来完成。基类destroy只是从this.el中删除其所有内容。您可以通过扩展VisComponent来创建一个具体的可视化组件。 以下最佳做法可最大程度地提高组件的清晰度，可重用性和互操作性（在本文档的其余部分中，假设Component被声明为VisComponent的扩展，例如BarChart）： 构造函数应该使用额外的一个参数选项来封装该组件所有的运行时选项。 组件应在Component.options中报告其预期的输入参数。 var component = new Component(el, options) 构造Candela组件的新实例。 el是用于可视化的有效容器。容器通常是DOM元素，例如 ，但对于某些可视化可能需要另一种容器类型。 options是一个对象，其中包含可视化的初始选项。这包括任何与可视化相关的数据，视觉匹配或其他设置。选项以{name：value}的形式指定。 注意：抽象超类的构造函数为空。您应该将构造函数用于VisComponent的特定子类。 component.render() 使用当前选项集将组件渲染到其容器中。 注意： VisComponent的render()方法只会抛出一个异常。 如果您确实希望组件在渲染时不执行任何操作，只需将方法重新定义为无操作即可。 component.update(options) 更改组件状态以反映选项。此方法允许对组件状态进行增量更改。选项的格式应与构造函数采用的格式相同。区别在于，只有被传输入此函数的参数会被更改，而任何未指定的参数应保持不变。 注意：VisComponent的update()函数返回一个promise对象。 因为每个组件的更新语义都不同，该对象将交付组件本身而不会更改组件。 component.destroy() 当不再需要该组件时，执行任何所需的清理。这可能只是简单的清空组件一直在使用的容器元素，也可能涉及取消注册事件侦听器等。 注意：VisComponent的destroy()函数只是清空顶层容器，因为这是最常见的清空操作。 component.empty() 清空组件容器元素的便捷方法。这可以在构造函数中用于准备容器元素，也可以在destroy函数中用于在组件之后进行清理。 component.serializationFormats serializationFormats参数是受支持格式的字符串列表。格式包括： ‘png’：PNG图片的base64编码的字符串。可以将字符串放在元素的src属性中以显示图像。 ‘svg’：SVG场景的base64编码的字符串。可以将字符串放在元素的src属性中以显示图像。 component.serialize(format) 将组件序列化为指定的格式。 Component.options 此静态属性是Option规范的数组(array)，其中包含此可视化接受的参数的描述。可以用于自检组件以实现诸如自动UI构建之类的功能。 Component.container 包含此可视化可以添加到的容器类型的静态字段。最常见的是DOMElement。 8.4.1.4.3 Mixins VisComponent在创建新组件时，Candela使用mixins向其添加功能。要使用mixin，模式如下： class MyCoolVisualization extends Mixin(candela.VisComponent) { . . . } Mixin使用以下模式定义: const Mixin = Base =&gt; class extends Base { mixinMethod() { . . . } }; 这是一个将基本类映射到新的未命名类的函数表达式。 换句话说，mixin是可以应用于VisComponent（或任何现有组件类）的函数，以产生具有附加功能的新类。 Candela自带有几个mixin，可在插件candela/plugins/mixin中找到。 Events() 向组件添加基本事件处理。该组件获得一个.on()函数和一个事件类型，该函数使用一个命名事件类型的字符串、在事件发生时调用的回调函数、以及一个使用事件类型和可选参数的.trigger()函数来触发该类事件。 InitSize() 根据实例化组件时this.el的大小，将width和height属性写入组件。 Resize() 每当包含元素的大小更改时，使用Events mixin来触发调整大小(resize)事件。 该事件使用元素的新宽度、高度、和组件的reference触发。 AutoResize() 合并了InitSize和Resize mixin的功能，并通过更新this.width和this.height属性自动响应resize事件。 VegaView() 实现Vega或Vega-Lite可视化组件。子类需要实现generateSpec()函数。generateSpec()函数根据视图选项返回适当的Vega / Vega-Lite Specification。 8.4.1.5 选项详述 选项详述将可视化的输入描述为Component.options数组(array)的一部分 。它是一个包含以下属性的对象： name (String) 选项的名称。 type (String) 选项的类型。类型和格式遵循 Girder Worker类型/格式。 format (String) 选项的格式（类型中的特定编码）。类型和格式遵循 Girder Worker类型/格式。 domain (Domain) 可选；限制选项的允许值集。 8.4.1.6 域详述 选项的域限制了选项的允许值集。它是具有以下属性的对象： mode (String) 域模式，‘choice’或’field’之一。 ’choice’模式将允许在“from”参数设置一组固定的选项集。 ’field’模式将允许来自另一个输入的单个变量或变量列表。如果选项类型为’string’，则选项为单个变量；如果选项类型为’ string_list’，则选项接受变量列表。 from (Array 或 String) 如果模式是’choice’，则它是用作下拉列表的字符串数组。如果模式为’field’，则为要从中提取变量的输入的名称。 fieldTypes (Array) 如果模式是’field’, 则指定支持的参数类型。此数组可以包含datalib支持的变量类型的任意组合，包括’string’，‘date’，‘number’，‘integer’，和 ‘boolean’。 8.4.1.7 实用工具 Candela 实用函数。 &gt; util.getElementSize(el) 返回一个对象，该对象的width和height包含以像素为单位的DOM元素el的当前宽度和高度。 util.vega 8.4.1.7.1 用于生成Vega规范的实用工具 util.vega.chart(template, el, options, done) 根据带有选项的实例化模板生成Vega图表。 template是代表图表的Vega模版。 el是放置Vega可视化文件的DOM元素。 options是{key：value} pair的对象，包含在编译模板时使用的选项。选项可以包含任意嵌套的对象和数组。 done是在生成Vega图表时调用的回调函数。该函数采用一个参数–即生成的Vega图表。 util.vega.transform(template, options) 返回具有已给选项的模板实例。这是js：funcʻutil.vega.chart`使用的基础函数，用于在使用Vega库渲染之前实例化其模板。 template是Vega模板。 options是{key：value}pair的对象，包含在编译模板时使用的选项。选项可以包含任意嵌套的对象和数组。 8.4.2 Candela Python API Candela Python代码库允许在Jupyter Notebook中使用交互式Candela可视化效果。 candela.components.ComponentName(**options) 根据已给可选变量创建一个代表Candela可视化效果的对象。ComponentName是Candela组件的名称，例如ScatterPlot。有关组件及其选项的完整列表，请参见组件。 如果将pandas DataFrame作为可选参数传入函数，在将其发送到Candela可视化组件之前，它将被自动转换为以下格式的记录列表： [{“a”: 1, “b”: “foo”}, {“a”: 2, “b”: “baz”}]。 要显示组件，只需简单的将可视化（不需要将其分配给其他变量）作为Notebook单元格中的最后一条语句即可。您还可以使用vis.display()来从单元格中的任意位置显示可视化效果。 8.4.3 Candela R API Candela R代码库通过将Candela转为htmlwidgets来启用R Studio中的交互式Candela可视化效果。 candela(name, …) 创建一个代表定选项指定的Candela可视化效果的小部件。name是Candela组件的名称，例如“ScatterPlot”。有关组件及其选项的完整列表，请参见组件。 Creates a widget representing the Candela visualization specified by the given options. 如果将data frame作为可选变量传入函数，在将其发送到Candela可视化组件之前，它将被自动转换为以下格式的记录列表： [{“a”: 1, “b”: “foo”}, {“a”: 2, “b”: “baz”}]。 8.5 开发人员文件 8.5.1 编码规范指南 我们所有JavaScript代码都遵循JavaScript Semistandard编码规范。 8.5.2 创建Candela代码发布 要执行Candela的新版本发布，请按照以下步骤操作。假设master上的代码已准备好转换为新版本（即，它已通过所有测试并包含新版本所需的所有新功能）。在此示例中，我们将模拟新发行版的版本号为1.2.0。 创建一个新的发行分支，名为release-1.2.0： git checkout -b release-1.2.0 master 通过编辑package.json将版本号提升到1.2.0。使用提交消息“ 提升版本号以发布”进行提交，然后推送分支： vim package.json git commit -am &#39;提升版本号以发布&#39; git push -u origin release-1.2.0 新建一个本地分支以将您的位置保存在此处的提交树中。请确保您的checkout仍为1.2.0版。您可以执行以下操作： git branch save-point 使用“production” NPM脚本构建分发文件： npm run build:production 这将会创建一个dist目录，其中包含两个JavaScript文件（普通版和精简版）。 提交production文件，然后再次推送。 git add dist git commit -m &#39;添加production文件以发布&#39; git push 从release-1.2.0分支创建代码合并请求。请确保将请求的基础分支定为release分支，而不是master分支。 等待“LGTM”（Looks Good To Me）确认信息，然后合并拉取请求并删除release-1.2.0分支。 检出release分支，拉取，标记发布，推送，然后删除release-1.2.0分支。 git checkout release git pull git tag v1.2.0 git push --tags git branch -d release-1.2.0 将新程序包发布到NPM, 您将需要首先使用NPM凭据登录。 npm login npm publish 将保存点分支合并到master中（请勿使用快进合并（fast-forward merge）。因为这是一种特殊的提交类型，它会准备master分支使用新的版本号的下一次开发，而不是添加新功能）。 其次推送，然后删除savepoint。请确保您没有合并release-1.2或release到master中；我们不希望distribution files合并进主线开发分支。 git checkout master git merge save-point git branch -d save-point git push 发行过程到此结束。您发布了一个带有标签的新发行版，并在发行分支上进行了相应的提交， 而master会更新软件包的版本号，以备进一步开发。 8.5.3 测试 8.5.3.1 图像测试 Candela的测试阶段之一就是图像测试：可视化组件的图像会以编程的方式被生成，和基准图像进行比较。 图像会自动上传到Kitware’s Girder 实例，通过Travis构建编号（build number）分类，可以被所有人查看。 "],["greek-translation-of-edav-infohisto.html", "Chapter 9 Greek translation of edav.info/histo 9.1 Διάγραμμα: Ιστόγραμμα 9.2 Επισκόπηση 9.3 Σύνοψη 9.4 Simple examples 9.5 Θεωρία 9.6 Τύποι ιστογραμμάτων 9.7 Παράμετροι 9.8 Διαδραστικά ιστογράμματα με το ggvis 9.9 Εξωτερικές πηγές", " Chapter 9 Greek translation of edav.info/histo Kassiani Papasotiriou 9.1 Διάγραμμα: Ιστόγραμμα 9.2 Επισκόπηση Αυτή η ενότητα καλύπτει τον τρόπο δημιουργίας ιστογραμμάτων. 9.3 Σύνοψη Δώσε μου ένα πλήρες παράδειγμα! Ορίστε μια εφαρμογή ιστογραμμάτων που εξετάζει το πώς άλλαξαν τα ράμφη των σπίνων των Νησιών Γκαλαπάγκος λόγω εξωτερικών παραγόντων: Και εδώ είναι ο κώδικας: library(Sleuth3) # data library(ggplot2) # plotting # load data finches &lt;- Sleuth3::case0201 # finch histograms by year with overlayed density curves ggplot(finches, aes(x = Depth, y = ..density..)) + # plotting geom_histogram(bins = 20, colour = &quot;#80593D&quot;, fill = &quot;#9FC29F&quot;, boundary = 0) + geom_density(color = &quot;#3D6480&quot;) + facet_wrap(~Year) + # formatting ggtitle(&quot;Μεγάλη Ξηρασία Οδήγησε σε Σπίνους με Μεγαλύτερα Ράμφη&quot;, subtitle = &quot;Πυκνότητα Βάθους Ραμφών των Σπίνων των Γκαλαπάγκος ανά Έτος&quot;) + labs(x = &quot;Βάθος Ράμφους (mm)&quot;, caption = &quot;Source: Sleuth3::case0201&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) Για περισσότερες πληροφορίες σχετικά με αυτό το σύνολο δεδομένων, γράψτε ?Sleuth3::case0201 στην κονσόλα. 9.4 Simple examples Έη, όπα, στάσου! Πολύ απλούστερο παρακαλώ! Ας χρησιμοποιήσουμε ένα πολύ απλό σύνολο δεδομένων: # store data x &lt;- c(50, 51, 53, 55, 56, 60, 65, 65, 68) 9.4.1 Ιστόγραμμα με χρήση βασικής R # plot data hist(x, col = &quot;lightblue&quot;, main = &quot;Ιστόγραμμα βασικής R για το x&quot;) Το πλεονέκτημα του ιστογράμματος βασικής R είναι πως μπορεί να ρυθμιστεί εύκολα. Στην πραγματικότητα, το μόνο που χρειάζεσαι για να απεικονίσεις γραφικά τα συγκεκριμένα δεδομένα x είναι η hist(x), αλλά συμπεριλάβαμε λίγο χρώμα και έναν τίτλο ώστε να τα κάνουμε πιο ευπαρουσίαστα. Πλήρης τεκμηρίωση σχετικά με τη hist() μπορεί να βρεθεί εδώ 9.4.2 Ιστόγραμμα με χρήση ggplot2 # import ggplot library(ggplot2) # must store data as dataframe df &lt;- data.frame(x) # plot data ggplot(df, aes(x)) + geom_histogram(color = &quot;grey&quot;, fill = &quot;lightBlue&quot;, binwidth = 5, center = 52.5) + ggtitle(&quot;Ιστόγραμμα ggplot2 για το x&quot;) Η εκδοχή με ggplot είναι λίγο πιο περίπλοκη φαινομενικά, αλλά ως αποτέλεσμα παίρνεις μεγαλύτερη ισχύ και έλεγχο. Σημείωση: Όπως φαίνεται παραπάνω, η ggplot αναμένει ένα πλαίσιο δεδομένων, οπότε εάν λαμβάνεις ένα σφάλμα όπου “η R δεν ξέρει τι να κάνει” όπως αυτό: ggplot dataframe error βεβαιώσου πως χρησιμοποιείς ένα πλαίσιο δεδομένων. 9.5 Θεωρία Σε γενικές γραμμές, το ιστόγραμμα είναι μία από πολλές επιλογές για την προβολή συνεχών δεδομένων. Το ιστόγραμμα μπορεί να δημιουργηθεί εύκολα και γρήγορα. Τα ιστογράμματα είναι λίγο πολύ αυτονόητα: δείχνουν την εμπειρική κατανομή των δεδομένων σου σε ένα σύνολο διαστημάτων. Τα ιστογράμματα μπορούν να χρησιμοποιηθούν σε ανεπεξέργαστα δεδομένα για να δείξουν γρήγορα την κατανομή χωρίς πολλούς χειρισμούς. Χρησιμοποίησε ένα ιστόγραμμα για να πάρεις μια βασική αίσθηση της κατανομής έχοντας ελάχιστες απαιτήσεις για επεξεργασία. • Για περισσότερες πληροφορίες σχετικά με τα ιστογράμματα και τις συνεχείς μεταβλητές, δες το Κεφάλαιο 3 του βιβλίου. 9.6 Τύποι ιστογραμμάτων Χρησιμοποίησε ένα ιστόγραμμα για να δείξεις την κατανομή μιας συνεχούς μεταβλητής. Η κλίμακα του άξονα y μπορεί να αναπαρασταθεί με διάφορους τρόπους για να εκφράσει διαφορετικά αποτελέσματα: 9.6.1 Συχνότητα ή μέτρηση y = αριθμός τιμών που υπάγονται στην κάθε ζώνη 9.6.2 Ιστόγραμμα σχετικής συχνότητας y = αριθμός τιμών που υπάγονται στην κάθε ζώνη / συνολικός αριθμός τιμών 9.6.3 Ιστόγραμμα συνολικής συχνότητας y = συνολικός αριθμός τιμών &lt;= (ή &lt;) του άνω ορίου της ζώνης 9.6.4 Πυκνότητα y = σχετική συχνότητα / εύρος ζώνης 9.7 Παράμετροι 9.7.1 Όρια ζωνών Σκέψου τα όρια των ζωνών και εάν ένα σημείο θα πέσει στην αριστερή ή τη δεξιά ζώνη όταν βρίσκεται πάνω στο όριο. # format layout op &lt;- par(mfrow = c(1, 2), las = 1) # right closed hist(x, col = &quot;lightblue&quot;, ylim = c(0, 4), xlab = &quot;δεξί κλειστό (55, 60]&quot;, font.lab = 2) # right open hist(x, col = &quot;lightblue&quot;, right = FALSE, ylim = c(0, 4), xlab = &quot;δεξί ανοιχτό [55, 60)&quot;, font.lab = 2) 9.7.2 Αριθμός ζωνών Ο προεπιλεγμένος αριθμός των 30 ζωνών στη ggplot2 δεν είναι πάντα ιδανικός, οπότε σκέψου να τον αλλάξεις εάν τα πράγματα φαίνονται περίεργα. Μπορείς να καθορίσεις το εύρος ρητά με το binwidth ή να δώσεις τον επιθυμητό αριθμό ζωνών με το bins. # default...note the pop-up about default bin number ggplot(finches, aes(x = Depth)) + geom_histogram() + ggtitle(&quot;Προεπιλογή με αναδυόμενο παράθυρο για τον αριθμό ζωνών&quot;) Ακολουθούν παραδείγματα αλλαγής των ζωνών με χρήση των δύο τρόπων που περιγράφηκαν παραπάνω: # using binwidth p1 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(binwidth = 0.5, boundary = 6) + ggtitle(&quot;Αλλάχθηκε η τιμή του binwidth&quot;) # using bins p2 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(bins = 48, boundary = 6) + ggtitle(&quot;Αλλάχθηκε η τιμή του bins&quot;) # format plot layout library(gridExtra) grid.arrange(p1, p2, ncol = 2) 9.7.3 Ευθυγράμμιση ζωνών Βεβαιώσου ότι οι άξονες αντικατοπτρίζουν τα πραγματικά όρια του ιστογράμματος. Μπορείς να χρησιμοποιήσεις το boundary για να προσδιορίσεις το τέλος οποιασδήποτε ζώνης ή το center για να προσδιορίσεις το κέντρο οποιασδήποτε ζώνης. Η ggplot2 θα μπορέσει να υπολογίσει πού να τοποθετήσει τις υπόλοιπες ζώνες. (Επίσης, παρατήρησε πως όταν το όριο άλλαξε, ο αριθμός των ζωνών μειώθηκε κατά μία. Αυτό συμβαίνει επειδή ως προεπιλογή οι ζώνες είναι κεντραρισμένες και υπερκαλύπτουν (πιο κάτω/ παραπάνω) το εύρος των δεδομένων.) df &lt;- data.frame(x) # default alignment ggplot(df, aes(x)) + geom_histogram(binwidth = 5, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Προεπιλεγμένη Ευθυγράμμιση Ζωνών&quot;) # specify alignment with boundary p3 &lt;- ggplot(df, aes(x)) + geom_histogram(binwidth = 5, boundary = 60, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Ευθ. Ζωνών με χρήση ορίων&quot;) # specify alignment with center p4 &lt;- ggplot(df, aes(x)) + geom_histogram(binwidth = 5, center = 67.5, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Ευθ. Ζωνών με χρήση κέντρου&quot;) # format layout library(gridExtra) grid.arrange(p3, p4, ncol = 2) Σημείωση: Μη χρησιμοποιείς και το boundary και το center για ευθυγράμμιση των ζωνών. Διάλεξε μόνο το ένα. 9.8 Διαδραστικά ιστογράμματα με το ggvis To πακέτο ggvis δεν βρίσκεται σε εξέλιξη επί του παρόντος, αλλά κάνει ορισμένα πράγματα πολύ καλά, όπως η ενεργή προσαρμογή των παραμέτρων ενός ιστογράμματος κατά την συγγραφή του κώδικα. Από τη στιγμή που οι εικόνες δε μπορούν να μοιραστούν με knitting (όπως συμβαίνει με άλλα πακέτα, όπως το plotly), παρουσιάζουμε εδώ τον κώδικα, αλλά όχι την έξοδο. Για να τα δοκιμάσεις, αντίγραψε και επικόλλησε σε μια συνεδρία R. 9.8.1 Διαδραστική αλλαγή του εύρου ζώνης library(tidyverse) library(ggvis) faithful %&gt;% ggvis(~eruptions) %&gt;% layer_histograms(fill := &quot;lightblue&quot;, width = input_slider(0.1, 2, value = .1, step = .1, label = &quot;width&quot;)) 9.8.2 Παράδειγμα ΑΕΠ df &lt;-read.csv(&quot;countries2012.csv&quot;) df %&gt;% ggvis(~GDP) %&gt;% layer_histograms(fill := &quot;green&quot;, width = input_slider(500, 10000, value = 5000, step = 500, label = &quot;width&quot;)) 9.8.3 Διαδραστική αλλαγή κέντρου df &lt;- data.frame(x = c(50, 51, 53, 55, 56, 60, 65, 65, 68)) df %&gt;% ggvis(~x) %&gt;% layer_histograms(fill := &quot;red&quot;, width = input_slider(1, 10, value = 5, step = 1, label = &quot;width&quot;), center = input_slider(50, 55, value = 52.5, step = .5, label = &quot;center&quot;)) 9.8.4 Αλλαγή κέντρου (με τις τιμές δεδομένων που εμφανίζονται) df &lt;- data.frame(x = c(50, 51, 53, 55, 56, 60, 65, 65, 68), y = c(.5, .5, .5, .5, .5, .5, .5, 1.5, .5)) df %&gt;% ggvis(~x, ~y) %&gt;% layer_histograms(fill := &quot;lightcyan&quot;, width = 5, center = input_slider(45, 55, value = 45, step = 1, label = &quot;center&quot;)) %&gt;% layer_points(fill := &quot;blue&quot;, size := 200) %&gt;% add_axis(&quot;x&quot;, properties = axis_props(labels = list(fontSize = 20))) %&gt;% scale_numeric(&quot;x&quot;, domain = c(46, 72)) %&gt;% add_axis(&quot;y&quot;, values = 0:3, properties = axis_props(labels = list(fontSize = 20))) 9.8.5 Διαδραστική αλλαγή ορίου df %&gt;% ggvis(~x) %&gt;% layer_histograms(fill := &quot;red&quot;, width = input_slider(1, 10, value = 5, step = 1, label = &quot;width&quot;), boundary = input_slider(47.5, 50, value = 50, step = .5, label = &quot;boundary&quot;)) 9.9 Εξωτερικές πηγές Τεκμηρίωση του hist: Σελίδα τεκμηρίωσης ιστογράμματος της βασικής R. Σκονάκι της ggplot2: Πάντα καλό να το έχεις παραδίπλα. "],["korean-translation-of-scatterplot.html", "Chapter 10 Korean translation of scatterplot 10.1 개요 10.2 요약 10.3 간단한 예시 10.4 이론 10.5 사용 시기 10.6 고려 사항 10.7 변경 10.8 추가 자료", " Chapter 10 Korean translation of scatterplot 산점도 by Matthew Lim *Source: https://edav.info/scatter.html 10.1 개요 R을 이용해 산점도를 그리는 방법 10.2 요약 예시 지상에 사는 포유류 62종의 뇌무게와 몸무게 사이의 관계 사용된 코드: library(ggplot2) # 그래프 mammals &lt;- MASS::mammals # 색상 비율 ratio &lt;- mammals$brain / (mammals$body*1000) ggplot(mammals, aes(x = body, y = brain)) + # 색상별로 그룹지정 후 포인트 그리기 geom_point(aes(fill = ifelse(ratio &gt;= 0.02, &quot;#0000ff&quot;, ifelse(ratio &gt;= 0.01 &amp; ratio &lt; 0.02, &quot;#00ff00&quot;, ifelse(ratio &gt;= 0.005 &amp; ratio &lt; 0.01, &quot;#00ffff&quot;, ifelse(ratio &gt;= 0.001 &amp; ratio &lt; 0.005, &quot;#ffff00&quot;, &quot;#ffffff&quot;))))), col = &quot;#656565&quot;, alpha = 0.5, size = 4, shape = 21) + # 데이터 포인트에 대한 텍스트 삽입 geom_text(aes(label = ifelse(row.names(mammals) %in% c(&quot;Mouse&quot;, &quot;Human&quot;, &quot;Asian elephant&quot;, &quot;Chimpanzee&quot;, &quot;Owl monkey&quot;, &quot;Ground squirrel&quot;), paste(as.character(row.names(mammals)), &quot;→&quot;, sep = &quot; &quot;),&#39;&#39;)), hjust = 1.12, vjust = 0.3, col = &quot;grey35&quot;) + geom_text(aes(label = ifelse(row.names(mammals) %in% c(&quot;Golden hamster&quot;, &quot;Kangaroo&quot;, &quot;Water opossum&quot;, &quot;Cow&quot;), paste(&quot;←&quot;, as.character(row.names(mammals)), sep = &quot; &quot;),&#39;&#39;)), hjust = -0.12, vjust = 0.35, col = &quot;grey35&quot;) + # 범례/색상 커스터마이제이션 scale_fill_manual(name = &quot;Brain Weight, as the\\n% of Body Weight&quot;, # values = c(&#39;#e66101&#39;,&#39;#fdb863&#39;,&#39;#b2abd2&#39;,&#39;#5e3c99&#39;), values = c(&#39;#d7191c&#39;,&#39;#fdae61&#39;,&#39;#ffffbf&#39;,&#39;#abd9e9&#39;,&#39;#2c7bb6&#39;), breaks = c(&quot;#0000ff&quot;, &quot;#00ff00&quot;, &quot;#00ffff&quot;, &quot;#ffff00&quot;, &quot;#ffffff&quot;), labels = c(&quot;Greater than 2%&quot;, &quot;Between 1%-2%&quot;, &quot;Between 0.5%-1%&quot;, &quot;Between 0.1%-0.5%&quot;, &quot;Less than 0.1%&quot;)) + # 포맷팅 scale_x_log10(name = &quot;Body Weight&quot;, breaks = c(0.01, 1, 100, 10000), labels = c(&quot;10 g&quot;, &quot;1 kg&quot;, &quot;100 kg&quot;, &quot;10K kg&quot;)) + scale_y_log10(name = &quot;Brain Weight&quot;, breaks = c(1, 10, 100, 1000), labels = c(&quot;1 g&quot;, &quot;10 g&quot;, &quot;100 g&quot;, &quot;1 kg&quot;)) + ggtitle(&quot;An Elephant Never Forgets...How Big A Brain It Has&quot;, subtitle = &quot;Brain and Body Weights of Sixty-Two Species of Land Mammals&quot;) + labs(caption = &quot;Source: MASS::mammals&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) + theme(legend.position = c(0.832, 0.21)) 이 데이터셋에 대한 더 많은 정보가 궁금하시다면 콘솔에 ?MASS::mammals을 입력하세요. 맨 오른쪽 상단 끝에 있는 점이 궁금하셨다면 그 점은 다른 종의 코끼리입니다. 좀 더 구체적으론 아프리카 코끼리입니다. 아프리카 코끼리도 자기 뇌가 얼마나 큰지 잊지않죠. 10.3 간단한 예시 이전 예시는 너무 복잡했어요! 좀 더 간단하게 부탁해요! 이번엔 GDAdata에서 SpeedSki 데이터셋을 통해 참가자가 태어난 해와 그들의 속도의 관계에 대해 알아봅시다: library(GDAdata) head(SpeedSki, n = 7) ## Rank Bib FIS.Code Name Year Nation Speed Sex Event ## 1 1 61 7039 ORIGONE Simone 1979 ITA 211.67 Male Speed One ## 2 2 59 7078 ORIGONE Ivan 1987 ITA 209.70 Male Speed One ## 3 3 66 190130 MONTES Bastien 1985 FRA 209.69 Male Speed One ## 4 4 57 7178 SCHROTTSHAMMER Klaus 1979 AUT 209.67 Male Speed One ## 5 5 69 510089 MAY Philippe 1970 SUI 209.19 Male Speed One ## 6 6 75 7204 BILLY Louis 1993 FRA 208.33 Male Speed One ## 7 7 67 7053 PERSSON Daniel 1975 SWE 208.03 Male Speed One ## no.of.runs ## 1 4 ## 2 4 ## 3 4 ## 4 4 ## 5 4 ## 6 4 ## 7 4 10.3.1 base R을 이용한 산점도 x &lt;- SpeedSki$Year y &lt;- SpeedSki$Speed # 그래프 삽입 plot(x, y, main = &quot;Scatterplot of Speed vs. Birth Year&quot;) 두개의 변수만 있으면 아주 간단하게 Base R을 통해 산점도를 그릴 수 있습니다. 산점도를 통해 범주 변수를 그릴 수도 있지만 대게 연속 변수를 그릴 때 사용됩니다. 10.3.2 ggplot2를 이용한 산점도 library(GDAdata) # 데이터 library(ggplot2) # 그래프 # 메인 그래프 scatter &lt;- ggplot(SpeedSki, aes(Year, Speed)) + geom_point() # 타이틀, 축 이름 추가 scatter + labs(x = &quot;Birth Year&quot;, y = &quot;Speed Achieved (km/hr)&quot;) + ggtitle(&quot;Ninety-One Skiers by Birth Year and Speed Achieved&quot;) ggplot2을 이용해서 산점도를 아주 간단하게 그릴 수 있습니다. geom_point() 코드를 통해 한 그래프에 2개의 aesthetic을 그릴 수 있습니다. 또한, 추가적인 포맷을 통해 그래프를 좀 더 깔끔하게 만드는데 더 욱 더 용이합니다. (실질적으로 필요한건 데이터와 aesthetics과 geom입니다). 10.4 이론 산점도를 통해 변수간의 상관관계를 아주 쉽게 이해할 수 있습니다. 예를 들어 section 13.2의 산점도를 보면 포유류의 뇌무게와 몸무게가 정적 상관관계를 가지고 있는걸 볼 수 있습니다. 산점도를 통해 변수들이 상관관계가 있는지, 있다면 정적 상관인지 부적 상관인지 알 수 있습니다. 하지만 상관관계를 원인과 혼동하시면 안됩니다! 이제 어떻게하면 산점도에 대한 이해도를 높힐 수 있을지 알아봅시다. For more info about adding lines/contours, comparing groups, and plotting continuous variables check out Chapter 5 of the textbook. 10.5 사용 시기 산점도는 변수들간의 관계를 알아볼때 유용합니다. 당신이 변수들간의 관계가 궁금하다면 산점도부터 시작해보세요. 10.6 고려 사항 10.6.1 겹치는 데이터 비슷한 값의 데이터는 산점도에서 겹쳐질 것이며 이는 문제를 일으킬 수 있습니다. 해결방안으로 alpha blending이나 jittering을 고려해보세요 (Overlapping Data의 Iris Walkthrough섹션의 링크). 10.6.2 스케일링 스케일링이 어떻게 산점도의 해석을 바꿀 수 있는지 고려하세요: library(ggplot2) num_points &lt;- 100 wide_x &lt;- c(rnorm(n = 50, mean = 100, sd = 2), rnorm(n = 50, mean = 10, sd = 2)) wide_y &lt;- rnorm(n = num_points, mean = 5, sd = 2) df &lt;- data.frame(wide_x, wide_y) ggplot(df, aes(wide_x, wide_y)) + geom_point() + ggtitle(&quot;Linear X-Axis&quot;) ggplot(df, aes(wide_x, wide_y)) + geom_point() + ggtitle(&quot;Log-10 X-Axis&quot;) + scale_x_log10() 10.7 변경 10.7.1 등고선 등고선은 데이터의 밀도에 대해 알려줍니다. SpeedSki 데이터셋을 이용해 등고선에 대해 알아봅시다. geom_density_2d()을 사용해 등고선을 추가할 수 있습니다: ggplot(SpeedSki, aes(Year, Speed)) + geom_density_2d() 등고선은 다른 그래프와 사용시 가장 효율적입니다: ggplot(SpeedSki, aes(Year, Speed)) + geom_point() + geom_density_2d(bins = 5) 10.7.2 산점도 행렬 여러개의 매개변수를 비교하고 싶다면 사점도 행렬을 사용하는 것을 고려해보세요. 산점도 행렬을 통해 좀 더 효율적으로 변수들을 비교할 수 있습니다. ggplot2movies패키지의 movies 데이터셋을 통해 산점도 행렬에 대해 더 자세히 알아봅시다. base R의 plot() 펑션을 통해 산점도 행렬을 그릴 수 있습니다: library(ggplot2movies) # 데이터 library(dplyr) # 데이터 편집 index &lt;- sample(nrow(movies), 500) #샘플 데이터 moviedf &lt;- movies[index,] # 데이터 프레임 splomvar &lt;- moviedf %&gt;% dplyr::select(length, budget, votes, rating, year) plot(splomvar) base R의 plot() 펑션을 개인적인 연구를 위해 사용하는건 괜찮지만 프레젠테이션을 위해 해당 펑션을 사용하는 것은 추천드리지 않습니다. 해당 펑션을 사용해 산점도 행렬을 그릴 시 Hermann grid illusion 때문에 해당 그래프를 해석하기게 매우 어렵습니다. lattice의 splom() 펑션을 통해 이 문제를 해결할 수 있습니다: library(lattice) #sploms splom(splomvar) 10.8 추가 자료 Quick-R article Base R을 통한 산점도. 산점도 행렬, 고밀도, 3D 버전의 간단한 예시부터 어려운 예시까지 있습니다. STHDA Base R: Base R을 통한 산점도에 대한 자료. 더 많은 예시가 있습니다. STHDA ggplot2: ggplot2를 통한 산점도에 대한 자료. 포맷과 face wraps에 대해 더 자세히 알려줍니다. Stack Overflow geom_point()의 포인트에 라벨을 더해주는 방법 ggplot2 cheatsheet: 언제나 가지고 있으면 좋은 자료. "],["tableau-intro-tutorial-explained-with-proset2.html", "Chapter 11 Tableau intro tutorial explained with proset2", " Chapter 11 Tableau intro tutorial explained with proset2 Yue Wang For the community contribution project, I will briefly introduce Tableau, the major features of this product, and other relevant products that are used in a different setting. I will introduce structure of the interfaces, importation of data, the supported files of data, supported data types, how to build worksheets and an interactive dashboard. I’ll use the Problem1 from Problem Set 2 to do the demo. This problem includes recoding of factor levels, vertical/horizontal bar chart, and horizontal bar chart of proportion. Although it only covers bar chart, I believe this will be a great first step to learn about how Tableau generally works. After doing the demo, I’ll draw a comparison with R and Excel and reemphasize the context of using Tableau. You can check the video through this link: https://www.bilibili.com/video/BV1py4y167YF/ "],["github-initial-setup.html", "Chapter 12 Github Initial Setup", " Chapter 12 Github Initial Setup Create a repo called “CC20” by following the instructions written in the bookdown-template. In index.Rmd, edit the title, github-repo and add description. In _bookdown.yml, edit relevant github information. In index.Rmd, include “Chapter 1: Instructions” similar to CC19. Add “Chapter 2: The Sample Project” by creating sample_project.Rmd. In _bookdown.yml, define our own order of Rmd files for the book in a field named rmd_files. Without rmd_files, the table of content of the book would be ordered alphabetically by the title of each Rmd file. Please read bookdown Usage for further reference. "]]
